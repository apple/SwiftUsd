# Differences in Swift

Learn how the OpenUSD API is different in Swift

## Overview
When using OpenUSD in Swift, there are some key differences and potential pitfalls you should know about. 


### UsdStage
In Swift, `UsdStage` is imported as a reference (class) type, meaning that you can hold a `UsdStage` directly in a Swift class, struct, enum, or local variable. Swift automatically inserts retain and release calls as needed when the stage is used, and can interoperate with C++ code that uses Pixar smart pointers for reference counting.  

#### Acquiring a stage
When acquiring a `UsdStage`, use [`Overlay.Dereference(_:)`](doc:OpenUSD/C++/Overlay/Dereference(_:)-67vpz) to dereference the `TfRefPtr<UsdStage>` returned by C++.  
``` swift
let stage: pxr.UsdStage = Overlay.Dereference(pxr.UsdStage.CreateInMemory(.LoadAll))
```

> Warning: The autogenerated `pointee` property on `TfRefPtr<UsdStage>` is not safe. Always use [`Overlay.Dereference(_:)`](doc:OpenUSD/C++/Overlay/Dereference(_:)-67vpz) instead. 
```swift
let stage: pxr.UsdStage = pxr.UsdStage.CreateInMemory(.LoadAll).pointee // ❌ unsafe! Use Overlay.Dereference(...) instead
```

#### Passing a stage
When passing a `UsdStage` to the OpenUSD API, wrap it via [`Overlay.TfWeakPtr(_:)`](doc:OpenUSD/C++/Overlay/TfWeakPtr(_:)-8de9g). 
```swift
let stage = Overlay.Dereference(pxr.UsdStage.CreateNew("/tmp/mystage.usda", .LoadAll))
let xform = pxr.UsdGeomXform.Define(Overlay.TfWeakPtr(stage), "/hello")
```

#### Calling methods on a stage
When calling methods on a `UsdStage`, use the stage directly:
```swift
let stage = Overlay.Dereference(pxr.UsdStage.Open("/tmp/mystage.usda", .LoadAll))
let root = stage.GetPseudoRoot()
```

### SdfLayer
In Swift, `SdfLayer` is imported as a reference (class) type, just like `UsdStage`. 

#### Acquiring a layer
When acquiring a `SdfLayer`, use [`Overlay.Dereference(_:)`](doc:OpenUSD/C++/Overlay/Dereference(_:)-3edgv) to dereference the `TfWeakPtr<SdfLayer>` returned by C++. 
```swift
let stage: pxr.UsdStage = Overlay.Dereference(pxr.UsdStage.CreateInMemory(.LoadAll))
let layer: pxr.SdfLayer = Overlay.Dereference(stage.GetRootLayer())
```

> Warning: The autogenerated `pointee` property on `TfWeakPtr<SdfLayer>` is not safe. Always use [`Overlay.Dereference(_:)`](doc:OpenUSD/C++/Overlay/Dereference(_:)-3edgv) instead. 
```swift
let stage: pxr.UsdStage = Overlay.Dereference(pxr.UsdStage.CreateInMemory(.LoadAll))
let layer: pxr.SdfLayer = stage.GetRootLayer().pointee // ❌ unsafe! Use Overlay.Dereference(...) instead
```

#### Calling methods on a layer
When calling methods on a `SdfLayer`, use the layer directly:
```swift
let layer = Overlay.Dereference(stage.GetRootLayer())
let dirty = layer.IsDirty()
```

### Converting types to boolean values
In C++, many OpenUSD types have an `operator bool() const` method. In Swift, this has been mapped to an initializer on `Bool`. See <doc:CheckingForValidity> for more information. 
```swift
let hasSessionLayer = Bool(stage.GetSessionLayer())

let imageable = pxr.UsdGeomImageable(prim)
if Bool(imageable) { ... }

let attribute = stage.GetAttributeAtPath("/foo/bar.baz")
if Bool(attribute) { ... }
```

### Wrapped types for unavailable types
Some OpenUSD types are move-only in C++, which means they can't be imported into Swift.  
In some cases, a Swift wrapper type is provided in this Swift Package. For example, ``OpenUSD/Overlay/UsdPrimTypeInfoWrapper``. See <doc:WrappedTypes> for more information. 

### UsdPrimRange and for loops
`UsdPrimRange` conforms to `Sequence`, enabling the use of for-loops and `Sequence` methods like `filter`, `map`, and `reduce`
```swift
for prim in pxr.UsdPrim.PreAndPostVisit(stage.GetPseudoRoot()) {
    print(prim)
}

let abstractPrims: [pxr.UsdPrim] = stage.Traverse().filter { $0.IsAbstract() }
```

To access the `iterator` of `UsdPrimRange` in a for-loop, use `UsdPrimRange.withIterator()`:
```swift
for (iter, prim) in pxr.UsdPrim.PreAndPostVisit(stage.GetPseudoRoot()).withIterator() {
    let path = String(prim.GetPath().GetAsString())
    print(path, iter.IsPostVisit())
    if path == "/Hello" {
        iter.PruneChildren()
    }
}
```

### TfNotice
Swift code can register for `TfNotice` callbacks by using [`pxr.TfNotice.Register`](doc:/OpenUSD/C++/pxr/TfNotice/Register(_:_:)-olq9). Instead of creating a C++ class or struct that inherits from `pxr::TfWeakBase`, call [`pxr.TfNotice.Register`](doc:/OpenUSD/C++/pxr/TfNotice/Register(_:_:)-olq9) and pass a closure:

```swift
func registerWithRevoking(stage: pxr.UsdStage) {
    let key = pxr.TfNotice.Register(stage, pxr.UsdNotice.StageContentsChanged.self) { _ in
        print("Stage contents changed")
    }

    stage.SetStartTimeCode(5) // prints "Stage contents changed"
    stage.SetEndTimeCode(7) // prints "Stage contents changed"
    pxr.TfNotice.Revoke(key)
    stage.SetTimeCodesPerSecond(60) // no print
}
```
For more information, see <doc:WorkingWithTfNotice>.

### GfMatrix4d static factory methods
In C++, `pxr::GfMatrix4d().SetTranslate()` and `pxr::GfMatrix4d().SetRotate()` are valid expressions, but mutated method chaining on function return values is not supported in Swift.  
This Swift Package provides [`pxr.GfMatrix4d.MakeTranslate()`](doc:OpenUSD/C++/pxr/GfMatrix4d/MakeTranslate(_:)) and [`pxr.GfMatrix4d.MakeRotate()`](doc:OpenUSD/C++/pxr/GfMatrix4d/MakeRotate(_:)) to increase the ergonomics of `GfMatrix4d` in Swift. 
```swift
override open func cameraTransformBeforeZupCorrection(stage: pxr.UsdStage) -> pxr.GfMatrix4d {
    pxr.GfMatrix4d.MakeRotate(pxr.GfRotation(.XAxis(), tilt * 180 / .pi)) *
    pxr.GfMatrix4d.MakeRotate(pxr.GfRotation(.YAxis(), pan * 180 / .pi)) *
    pxr.GfMatrix4d.MakeTranslate(position)
}
```

### GetPrim()
In Swift, calling the `GetPrim()` method on a `UsdSchemaBase` subclass (e.g. `UsdGeomSphere`) causes a compiler crash.  
This Swift Package provides `Overlay.GetPrim<T>(_:T) -> pxr.UsdPrim`, substituting `T` for each subclass of `UsdSchemaBase`. 
```swift
let planePrim = pxr.UsdGeomMesh.Get(Overlay.TfWeakPtr(stage), planePath(anchor: anchor))
Overlay.GetPrim(planePrim).SetActive(true)
```

### Implicit member expressions
`SdfValueTypeNames` and tokens types like `UsdGeomTokensType` support implicit member expressions. 

```swift
var pbrShader = pxr.UsdShadeShader.Define(Overlay.TfWeakPtr(stage), "/TexModel/boardMat/PBRShader")
pbrShader.CreateInput("roughness", pxr.SdfValueTypeName.Float) // Without implicit member expressions
pbrShader.CreateInput("metallic", .Float) // With implicit member expressions
```

```swift
let xform1 = stage.DefinePrim("/hello", pxr.TfToken.UsdGeomTokens.Xform) // Without implicit member expressions
let xform2 = stage.DefinePrim("/hello/world", .UsdGeomTokens.Xform) // With implicit member expressions
```

### Nested enums
C++ unscoped enums nested in a namespace are not currently imported into Swift.
This Swift Package provides workarounds for all public enums, replacing the `pxr` root namespace with `Overlay`. For example, instead of `pxr.UsdStage.LoadAll`, use `Overlay.UsdStage.LoadAll`.  
See <doc:WrappedEnums> for more information.

### Closure-based API for UsdEditContext
`UsdEditContext` is a non-movable type in C++ and cannot currently be imported into Swift. Instead, use [`Overlay.withUsdEditContext()`](doc:OpenUSD/C++/Overlay/withUsdEditContext(_:_:_:)) for RAII-like patterns in Swift. See <doc:UsingEditContexts> for more details. 
```swift
let target = stage.GetEditTargetForLocalLayer(stage.GetSessionLayer())
Overlay.withUsdEditContext(stage, target) {
    let refSphere2 = stage.GetPrimAtPath("/refSphere2")
    refSphere2.SetActive(false)
}
```

```swift
// Add a UsdVariantSet with variant "red"
let rootPrim = stage.GetPrimAtPath("/hello")
let colorAttr = rootPrim.GetAttribute(.UsdGeomTokens.primvarsDisplayColor)
var vsets = rootPrim.GetVariantSets()
var vset = vsets.AddVariantSet("shadingVariant", .UsdListPositionBackOfPrependList)
vset.AddVariant("red", .UsdListPositionBackOfPrependList)

// Author a color in the "red" variant
vset.SetVariantSelection("red")
Overlay.withUsdEditContext(vset.GetVariantEditContext(pxr.SdfLayerHandle())) {
    let colorValue: pxr.VtVec3fArray = [pxr.GfVec3f(1, 0, 0)]
    colorAttr.Set(colorValue, pxr.UsdTimeCode.Default())
}
```
