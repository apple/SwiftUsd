// ===-------------------------------------------------------------------===//
// This source file is part of github.com/apple/SwiftUsd-ast-answerer
//
// Copyright Â© 2025 Apple Inc. and the SwiftUsd-ast-answerer authors. All Rights Reserved. 
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at: 
// https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.     
// 
// SPDX-License-Identifier: Apache-2.0
// ===-------------------------------------------------------------------===//

// This file was generated by SwiftUsd-ast-answerer. Do not edit!
#include "swiftUsd/generated/CustomStringConvertible.h"

std::string __Overlay::to_string(const pxr::ArchMemAdvice& x) {
    switch (x) {
    case pxr::ArchMemAdviceNormal: return "pxr::ArchMemAdviceNormal";
    case pxr::ArchMemAdviceWillNeed: return "pxr::ArchMemAdviceWillNeed";
    case pxr::ArchMemAdviceDontNeed: return "pxr::ArchMemAdviceDontNeed";
    case pxr::ArchMemAdviceRandomAccess: return "pxr::ArchMemAdviceRandomAccess";
    default: return "pxr::ArchMemAdvice(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::ArchFileAdvice& x) {
    switch (x) {
    case pxr::ArchFileAdviceNormal: return "pxr::ArchFileAdviceNormal";
    case pxr::ArchFileAdviceWillNeed: return "pxr::ArchFileAdviceWillNeed";
    case pxr::ArchFileAdviceDontNeed: return "pxr::ArchFileAdviceDontNeed";
    case pxr::ArchFileAdviceRandomAccess: return "pxr::ArchFileAdviceRandomAccess";
    default: return "pxr::ArchFileAdvice(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::ArchMemoryProtection& x) {
    switch (x) {
    case pxr::ArchProtectNoAccess: return "pxr::ArchProtectNoAccess";
    case pxr::ArchProtectReadOnly: return "pxr::ArchProtectReadOnly";
    case pxr::ArchProtectReadWrite: return "pxr::ArchProtectReadWrite";
    case pxr::ArchProtectReadWriteCopy: return "pxr::ArchProtectReadWriteCopy";
    default: return "pxr::ArchMemoryProtection(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::TfAnyWeakPtr& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::TfType& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::TfType::LegacyFlags& x) {
    switch (x) {
    case pxr::TfType::ABSTRACT: return "pxr::TfType::ABSTRACT";
    case pxr::TfType::CONCRETE: return "pxr::TfType::CONCRETE";
    case pxr::TfType::MANUFACTURABLE: return "pxr::TfType::MANUFACTURABLE";
    default: return "pxr::TfType::LegacyFlags(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::TfDiagnosticType& x) {
    switch (x) {
    case pxr::TF_DIAGNOSTIC_INVALID_TYPE: return "pxr::TF_DIAGNOSTIC_INVALID_TYPE";
    case pxr::TF_DIAGNOSTIC_CODING_ERROR_TYPE: return "pxr::TF_DIAGNOSTIC_CODING_ERROR_TYPE";
    case pxr::TF_DIAGNOSTIC_FATAL_CODING_ERROR_TYPE: return "pxr::TF_DIAGNOSTIC_FATAL_CODING_ERROR_TYPE";
    case pxr::TF_DIAGNOSTIC_RUNTIME_ERROR_TYPE: return "pxr::TF_DIAGNOSTIC_RUNTIME_ERROR_TYPE";
    case pxr::TF_DIAGNOSTIC_FATAL_ERROR_TYPE: return "pxr::TF_DIAGNOSTIC_FATAL_ERROR_TYPE";
    case pxr::TF_DIAGNOSTIC_NONFATAL_ERROR_TYPE: return "pxr::TF_DIAGNOSTIC_NONFATAL_ERROR_TYPE";
    case pxr::TF_DIAGNOSTIC_WARNING_TYPE: return "pxr::TF_DIAGNOSTIC_WARNING_TYPE";
    case pxr::TF_DIAGNOSTIC_STATUS_TYPE: return "pxr::TF_DIAGNOSTIC_STATUS_TYPE";
    case pxr::TF_APPLICATION_EXIT_TYPE: return "pxr::TF_APPLICATION_EXIT_TYPE";
    default: return "pxr::TfDiagnosticType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::TfBits& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::TfBits::Mode& x) {
    switch (x) {
    case pxr::TfBits::All: return "pxr::TfBits::All";
    case pxr::TfBits::AllSet: return "pxr::TfBits::AllSet";
    case pxr::TfBits::AllUnset: return "pxr::TfBits::AllUnset";
    default: return "pxr::TfBits::Mode(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::TfCompressedBits& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::TfCompressedBits::Mode& x) {
    switch (x) {
    case pxr::TfCompressedBits::Mode::All: return "pxr::TfCompressedBits::Mode::All";
    case pxr::TfCompressedBits::Mode::AllSet: return "pxr::TfCompressedBits::Mode::AllSet";
    case pxr::TfCompressedBits::Mode::AllUnset: return "pxr::TfCompressedBits::Mode::AllUnset";
    case pxr::TfCompressedBits::Mode::Platforms: return "pxr::TfCompressedBits::Mode::Platforms";
    default: return "pxr::TfCompressedBits::Mode(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::TfCompressedBits::ComplementTagType& x) {
    switch (x) {
    case pxr::TfCompressedBits::ComplementTag: return "pxr::TfCompressedBits::ComplementTag";
    default: return "pxr::TfCompressedBits::ComplementTagType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::TfEnum& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::TfStopwatch& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::TfNotice::Key& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::TfMallocTag::CallTree::PrintSetting& x) {
    switch (x) {
    case pxr::TfMallocTag::CallTree::TREE: return "pxr::TfMallocTag::CallTree::TREE";
    case pxr::TfMallocTag::CallTree::CALLSITES: return "pxr::TfMallocTag::CallTree::CALLSITES";
    case pxr::TfMallocTag::CallTree::BOTH: return "pxr::TfMallocTag::CallTree::BOTH";
    default: return "pxr::TfMallocTag::CallTree::PrintSetting(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::TfRefPtrTracker::TraceType& x) {
    switch (x) {
    case pxr::TfRefPtrTracker::Add: return "pxr::TfRefPtrTracker::Add";
    case pxr::TfRefPtrTracker::Assign: return "pxr::TfRefPtrTracker::Assign";
    default: return "pxr::TfRefPtrTracker::TraceType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::TfToken& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfBBox3d& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfMatrix4d& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfVec4d& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfVec4f& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfVec4h& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::pxr_half::half& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfVec4i& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfVec3d& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfVec3f& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfVec3h& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfVec3i& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfRange3d& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfRange3f& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfCamera::Projection& x) {
    switch (x) {
    case pxr::GfCamera::Perspective: return "pxr::GfCamera::Perspective";
    case pxr::GfCamera::Orthographic: return "pxr::GfCamera::Orthographic";
    default: return "pxr::GfCamera::Projection(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::GfCamera::FOVDirection& x) {
    switch (x) {
    case pxr::GfCamera::FOVHorizontal: return "pxr::GfCamera::FOVHorizontal";
    case pxr::GfCamera::FOVVertical: return "pxr::GfCamera::FOVVertical";
    default: return "pxr::GfCamera::FOVDirection(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::GfRange1f& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfRange1d& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfColor& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfVec2f& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfVec2d& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfVec2h& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfVec2i& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfMatrix3f& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfDualQuatd& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfQuatd& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfDualQuatf& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfQuatf& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfDualQuath& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfQuath& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfFrustum& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfFrustum::ProjectionType& x) {
    switch (x) {
    case pxr::GfFrustum::Orthographic: return "pxr::GfFrustum::Orthographic";
    case pxr::GfFrustum::Perspective: return "pxr::GfFrustum::Perspective";
    default: return "pxr::GfFrustum::ProjectionType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::GfPlane& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfRay& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfRange2d& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfRange2f& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfRotation& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfQuaternion& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfInterval& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfLine& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfLineSeg& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfMatrix2d& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfMatrix2f& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfMatrix3d& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfMatrix4f& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfMultiInterval& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfRect2i& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfSize2& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfSize3& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfTransform& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::GfNumericCastFailureType& x) {
    switch (x) {
    case pxr::GfNumericCastPosOverflow: return "pxr::GfNumericCastPosOverflow";
    case pxr::GfNumericCastNegOverflow: return "pxr::GfNumericCastNegOverflow";
    case pxr::GfNumericCastNaN: return "pxr::GfNumericCastNaN";
    default: return "pxr::GfNumericCastFailureType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::JsValue::Type& x) {
    switch (x) {
    case pxr::JsValue::ObjectType: return "pxr::JsValue::ObjectType";
    case pxr::JsValue::ArrayType: return "pxr::JsValue::ArrayType";
    case pxr::JsValue::StringType: return "pxr::JsValue::StringType";
    case pxr::JsValue::BoolType: return "pxr::JsValue::BoolType";
    case pxr::JsValue::IntType: return "pxr::JsValue::IntType";
    case pxr::JsValue::RealType: return "pxr::JsValue::RealType";
    case pxr::JsValue::NullType: return "pxr::JsValue::NullType";
    default: return "pxr::JsValue::Type(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::TraceEvent::BeginTag& x) {
    switch (x) {
    case pxr::TraceEvent::Begin: return "pxr::TraceEvent::Begin";
    default: return "pxr::TraceEvent::BeginTag(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::TraceEvent::EndTag& x) {
    switch (x) {
    case pxr::TraceEvent::End: return "pxr::TraceEvent::End";
    default: return "pxr::TraceEvent::EndTag(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::TraceEvent::TimespanTag& x) {
    switch (x) {
    case pxr::TraceEvent::Timespan: return "pxr::TraceEvent::Timespan";
    default: return "pxr::TraceEvent::TimespanTag(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::TraceEvent::MarkerTag& x) {
    switch (x) {
    case pxr::TraceEvent::Marker: return "pxr::TraceEvent::Marker";
    default: return "pxr::TraceEvent::MarkerTag(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::TraceEvent::CounterDeltaTag& x) {
    switch (x) {
    case pxr::TraceEvent::CounterDelta: return "pxr::TraceEvent::CounterDelta";
    default: return "pxr::TraceEvent::CounterDeltaTag(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::TraceEvent::CounterValueTag& x) {
    switch (x) {
    case pxr::TraceEvent::CounterValue: return "pxr::TraceEvent::CounterValue";
    default: return "pxr::TraceEvent::CounterValueTag(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::TraceEvent::DataTag& x) {
    switch (x) {
    case pxr::TraceEvent::Data: return "pxr::TraceEvent::Data";
    default: return "pxr::TraceEvent::DataTag(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::TraceEvent::EventType& x) {
    switch (x) {
    case pxr::TraceEvent::EventType::Unknown: return "pxr::TraceEvent::EventType::Unknown";
    case pxr::TraceEvent::EventType::Begin: return "pxr::TraceEvent::EventType::Begin";
    case pxr::TraceEvent::EventType::End: return "pxr::TraceEvent::EventType::End";
    case pxr::TraceEvent::EventType::Timespan: return "pxr::TraceEvent::EventType::Timespan";
    case pxr::TraceEvent::EventType::Marker: return "pxr::TraceEvent::EventType::Marker";
    case pxr::TraceEvent::EventType::CounterDelta: return "pxr::TraceEvent::EventType::CounterDelta";
    case pxr::TraceEvent::EventType::CounterValue: return "pxr::TraceEvent::EventType::CounterValue";
    case pxr::TraceEvent::EventType::ScopeData: return "pxr::TraceEvent::EventType::ScopeData";
    default: return "pxr::TraceEvent::EventType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::TraceEvent::DataType& x) {
    switch (x) {
    case pxr::TraceEvent::DataType::String: return "pxr::TraceEvent::DataType::String";
    case pxr::TraceEvent::DataType::Boolean: return "pxr::TraceEvent::DataType::Boolean";
    case pxr::TraceEvent::DataType::Int: return "pxr::TraceEvent::DataType::Int";
    case pxr::TraceEvent::DataType::UInt: return "pxr::TraceEvent::DataType::UInt";
    case pxr::TraceEvent::DataType::Float: return "pxr::TraceEvent::DataType::Float";
    case pxr::TraceEvent::DataType::Invalid: return "pxr::TraceEvent::DataType::Invalid";
    default: return "pxr::TraceEvent::DataType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::VtDualQuatdArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtDualQuatfArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtDualQuathArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtHalfArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtIntervalArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtMatrix2dArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtMatrix2fArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtMatrix3dArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtMatrix3fArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtMatrix4dArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtMatrix4fArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtQuatdArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtQuaternionArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtQuatfArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtQuathArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtRange1dArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtRange1fArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtRange2dArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtRange2fArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtRange3dArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtRange3fArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtRect2iArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtVec2dArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtVec2fArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtVec2hArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtVec2iArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtVec3dArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtVec3fArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtVec3hArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtVec3iArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtVec4dArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtVec4fArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtVec4hArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtVec4iArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtTokenArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtBoolArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtCharArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtDoubleArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtFloatArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtInt64Array& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtIntArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtShortArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtStringArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtUInt64Array& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtUCharArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtUIntArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtUShortArray& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtDictionary& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VtValue& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::UsdMetadataValueMap& x) {
    std::stringstream ss;
    ss << "< ";
    for (const auto& p : x) {
        ss << "<" << p.first << ": " << p.second << "> ";    }
    ss << ">";
    return ss.str();
}
std::string __Overlay::to_string(const pxr::TsSpline& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::TsInterpMode& x) {
    switch (x) {
    case pxr::TsInterpValueBlock: return "pxr::TsInterpValueBlock";
    case pxr::TsInterpHeld: return "pxr::TsInterpHeld";
    case pxr::TsInterpLinear: return "pxr::TsInterpLinear";
    case pxr::TsInterpCurve: return "pxr::TsInterpCurve";
    default: return "pxr::TsInterpMode(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::TsCurveType& x) {
    switch (x) {
    case pxr::TsCurveTypeBezier: return "pxr::TsCurveTypeBezier";
    case pxr::TsCurveTypeHermite: return "pxr::TsCurveTypeHermite";
    default: return "pxr::TsCurveType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::TsExtrapMode& x) {
    switch (x) {
    case pxr::TsExtrapValueBlock: return "pxr::TsExtrapValueBlock";
    case pxr::TsExtrapHeld: return "pxr::TsExtrapHeld";
    case pxr::TsExtrapLinear: return "pxr::TsExtrapLinear";
    case pxr::TsExtrapSloped: return "pxr::TsExtrapSloped";
    case pxr::TsExtrapLoopRepeat: return "pxr::TsExtrapLoopRepeat";
    case pxr::TsExtrapLoopReset: return "pxr::TsExtrapLoopReset";
    case pxr::TsExtrapLoopOscillate: return "pxr::TsExtrapLoopOscillate";
    default: return "pxr::TsExtrapMode(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::TsSplineSampleSource& x) {
    switch (x) {
    case pxr::TsSourcePreExtrap: return "pxr::TsSourcePreExtrap";
    case pxr::TsSourcePreExtrapLoop: return "pxr::TsSourcePreExtrapLoop";
    case pxr::TsSourceInnerLoopPreEcho: return "pxr::TsSourceInnerLoopPreEcho";
    case pxr::TsSourceInnerLoopProto: return "pxr::TsSourceInnerLoopProto";
    case pxr::TsSourceInnerLoopPostEcho: return "pxr::TsSourceInnerLoopPostEcho";
    case pxr::TsSourceKnotInterp: return "pxr::TsSourceKnotInterp";
    case pxr::TsSourcePostExtrap: return "pxr::TsSourcePostExtrap";
    case pxr::TsSourcePostExtrapLoop: return "pxr::TsSourcePostExtrapLoop";
    default: return "pxr::TsSplineSampleSource(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::TsTangentAlgorithm& x) {
    switch (x) {
    case pxr::TsTangentAlgorithmNone: return "pxr::TsTangentAlgorithmNone";
    case pxr::TsTangentAlgorithmCustom: return "pxr::TsTangentAlgorithmCustom";
    case pxr::TsTangentAlgorithmAutoEase: return "pxr::TsTangentAlgorithmAutoEase";
    default: return "pxr::TsTangentAlgorithm(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::TsAntiRegressionMode& x) {
    switch (x) {
    case pxr::TsAntiRegressionNone: return "pxr::TsAntiRegressionNone";
    case pxr::TsAntiRegressionContain: return "pxr::TsAntiRegressionContain";
    case pxr::TsAntiRegressionKeepRatio: return "pxr::TsAntiRegressionKeepRatio";
    case pxr::TsAntiRegressionKeepStart: return "pxr::TsAntiRegressionKeepStart";
    default: return "pxr::TsAntiRegressionMode(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::TsKnot& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::TsRegressionPreventer::InteractiveMode& x) {
    switch (x) {
    case pxr::TsRegressionPreventer::ModeLimitActive: return "pxr::TsRegressionPreventer::ModeLimitActive";
    case pxr::TsRegressionPreventer::ModeLimitOpposite: return "pxr::TsRegressionPreventer::ModeLimitOpposite";
    default: return "pxr::TsRegressionPreventer::InteractiveMode(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::SdfPath& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::SdfSpecType& x) {
    switch (x) {
    case pxr::SdfSpecTypeUnknown: return "pxr::SdfSpecTypeUnknown";
    case pxr::SdfSpecTypeAttribute: return "pxr::SdfSpecTypeAttribute";
    case pxr::SdfSpecTypeConnection: return "pxr::SdfSpecTypeConnection";
    case pxr::SdfSpecTypeExpression: return "pxr::SdfSpecTypeExpression";
    case pxr::SdfSpecTypeMapper: return "pxr::SdfSpecTypeMapper";
    case pxr::SdfSpecTypeMapperArg: return "pxr::SdfSpecTypeMapperArg";
    case pxr::SdfSpecTypePrim: return "pxr::SdfSpecTypePrim";
    case pxr::SdfSpecTypePseudoRoot: return "pxr::SdfSpecTypePseudoRoot";
    case pxr::SdfSpecTypeRelationship: return "pxr::SdfSpecTypeRelationship";
    case pxr::SdfSpecTypeRelationshipTarget: return "pxr::SdfSpecTypeRelationshipTarget";
    case pxr::SdfSpecTypeVariant: return "pxr::SdfSpecTypeVariant";
    case pxr::SdfSpecTypeVariantSet: return "pxr::SdfSpecTypeVariantSet";
    case pxr::SdfNumSpecTypes: return "pxr::SdfNumSpecTypes";
    default: return "pxr::SdfSpecType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::SdfSpecifier& x) {
    switch (x) {
    case pxr::SdfSpecifierDef: return "pxr::SdfSpecifierDef";
    case pxr::SdfSpecifierOver: return "pxr::SdfSpecifierOver";
    case pxr::SdfSpecifierClass: return "pxr::SdfSpecifierClass";
    case pxr::SdfNumSpecifiers: return "pxr::SdfNumSpecifiers";
    default: return "pxr::SdfSpecifier(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::SdfPermission& x) {
    switch (x) {
    case pxr::SdfPermissionPublic: return "pxr::SdfPermissionPublic";
    case pxr::SdfPermissionPrivate: return "pxr::SdfPermissionPrivate";
    case pxr::SdfNumPermissions: return "pxr::SdfNumPermissions";
    default: return "pxr::SdfPermission(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::SdfVariability& x) {
    switch (x) {
    case pxr::SdfVariabilityVarying: return "pxr::SdfVariabilityVarying";
    case pxr::SdfVariabilityUniform: return "pxr::SdfVariabilityUniform";
    case pxr::SdfNumVariabilities: return "pxr::SdfNumVariabilities";
    default: return "pxr::SdfVariability(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::SdfAuthoringError& x) {
    switch (x) {
    case pxr::SdfAuthoringErrorUnrecognizedFields: return "pxr::SdfAuthoringErrorUnrecognizedFields";
    case pxr::SdfAuthoringErrorUnrecognizedSpecType: return "pxr::SdfAuthoringErrorUnrecognizedSpecType";
    default: return "pxr::SdfAuthoringError(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::SdfAngularUnit& x) {
    switch (x) {
    case pxr::SdfAngularUnitDegrees: return "pxr::SdfAngularUnitDegrees";
    case pxr::SdfAngularUnitRadians: return "pxr::SdfAngularUnitRadians";
    default: return "pxr::SdfAngularUnit(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::SdfDimensionlessUnit& x) {
    switch (x) {
    case pxr::SdfDimensionlessUnitPercent: return "pxr::SdfDimensionlessUnitPercent";
    case pxr::SdfDimensionlessUnitDefault: return "pxr::SdfDimensionlessUnitDefault";
    default: return "pxr::SdfDimensionlessUnit(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::SdfLengthUnit& x) {
    switch (x) {
    case pxr::SdfLengthUnitMillimeter: return "pxr::SdfLengthUnitMillimeter";
    case pxr::SdfLengthUnitCentimeter: return "pxr::SdfLengthUnitCentimeter";
    case pxr::SdfLengthUnitDecimeter: return "pxr::SdfLengthUnitDecimeter";
    case pxr::SdfLengthUnitMeter: return "pxr::SdfLengthUnitMeter";
    case pxr::SdfLengthUnitKilometer: return "pxr::SdfLengthUnitKilometer";
    case pxr::SdfLengthUnitInch: return "pxr::SdfLengthUnitInch";
    case pxr::SdfLengthUnitFoot: return "pxr::SdfLengthUnitFoot";
    case pxr::SdfLengthUnitYard: return "pxr::SdfLengthUnitYard";
    case pxr::SdfLengthUnitMile: return "pxr::SdfLengthUnitMile";
    default: return "pxr::SdfLengthUnit(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::SdfUnregisteredValue& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::SdfValueBlock& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::SdfAnimationBlock& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::SdfHumanReadableValue& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::SdfAssetPath& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::SdfListOpType& x) {
    switch (x) {
    case pxr::SdfListOpTypeExplicit: return "pxr::SdfListOpTypeExplicit";
    case pxr::SdfListOpTypeAdded: return "pxr::SdfListOpTypeAdded";
    case pxr::SdfListOpTypeDeleted: return "pxr::SdfListOpTypeDeleted";
    case pxr::SdfListOpTypeOrdered: return "pxr::SdfListOpTypeOrdered";
    case pxr::SdfListOpTypePrepended: return "pxr::SdfListOpTypePrepended";
    case pxr::SdfListOpTypeAppended: return "pxr::SdfListOpTypeAppended";
    default: return "pxr::SdfListOpType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::SdfOpaqueValue& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::SdfPathExpression& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::SdfPathExpression::Op& x) {
    switch (x) {
    case pxr::SdfPathExpression::Complement: return "pxr::SdfPathExpression::Complement";
    case pxr::SdfPathExpression::ImpliedUnion: return "pxr::SdfPathExpression::ImpliedUnion";
    case pxr::SdfPathExpression::Union: return "pxr::SdfPathExpression::Union";
    case pxr::SdfPathExpression::Intersection: return "pxr::SdfPathExpression::Intersection";
    case pxr::SdfPathExpression::Difference: return "pxr::SdfPathExpression::Difference";
    case pxr::SdfPathExpression::ExpressionRef: return "pxr::SdfPathExpression::ExpressionRef";
    case pxr::SdfPathExpression::Pattern: return "pxr::SdfPathExpression::Pattern";
    default: return "pxr::SdfPathExpression::Op(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::SdfPredicateExpression& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::SdfPredicateExpression::FnCall::Kind& x) {
    switch (x) {
    case pxr::SdfPredicateExpression::FnCall::BareCall: return "pxr::SdfPredicateExpression::FnCall::BareCall";
    case pxr::SdfPredicateExpression::FnCall::ColonCall: return "pxr::SdfPredicateExpression::FnCall::ColonCall";
    case pxr::SdfPredicateExpression::FnCall::ParenCall: return "pxr::SdfPredicateExpression::FnCall::ParenCall";
    default: return "pxr::SdfPredicateExpression::FnCall::Kind(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::SdfPredicateExpression::Op& x) {
    switch (x) {
    case pxr::SdfPredicateExpression::Call: return "pxr::SdfPredicateExpression::Call";
    case pxr::SdfPredicateExpression::Not: return "pxr::SdfPredicateExpression::Not";
    case pxr::SdfPredicateExpression::ImpliedAnd: return "pxr::SdfPredicateExpression::ImpliedAnd";
    case pxr::SdfPredicateExpression::And: return "pxr::SdfPredicateExpression::And";
    case pxr::SdfPredicateExpression::Or: return "pxr::SdfPredicateExpression::Or";
    default: return "pxr::SdfPredicateExpression::Op(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::SdfTimeCode& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::SdfValueTypeName& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::SdfAttributeSpec& x) {
    if (x.IsDormant()) {
        return "dormant pxr::SdfAttributeSpec";
    }
    return "pxr::SdfAttributeSpec(" + x.GetLayer()->GetIdentifier() + ", " + x.GetPath().GetString() + ")";
}
std::string __Overlay::to_string(const pxr::SdfAttributeSpecHandle& x) {
    if (!x) {
        return "expired pxr::SdfAttributeSpecHandle";
    }
    return "pxr::SdfAttributeSpecHandle(" + __Overlay::to_string(x.GetSpec()) + ")";
}
std::string __Overlay::to_string(const pxr::SdfPropertySpecHandle& x) {
    if (!x) {
        return "expired pxr::SdfPropertySpecHandle";
    }
    return "pxr::SdfPropertySpecHandle(" + __Overlay::to_string(x.GetSpec()) + ")";
}
std::string __Overlay::to_string(const pxr::SdfPropertySpec& x) {
    if (x.IsDormant()) {
        return "dormant pxr::SdfPropertySpec";
    }
    return "pxr::SdfPropertySpec(" + x.GetLayer()->GetIdentifier() + ", " + x.GetPath().GetString() + ")";
}
std::string __Overlay::to_string(const pxr::SdfSpecHandle& x) {
    if (!x) {
        return "expired pxr::SdfSpecHandle";
    }
    return "pxr::SdfSpecHandle(" + __Overlay::to_string(x.GetSpec()) + ")";
}
std::string __Overlay::to_string(const pxr::SdfSpec& x) {
    if (x.IsDormant()) {
        return "dormant pxr::SdfSpec";
    }
    return "pxr::SdfSpec(" + x.GetLayer()->GetIdentifier() + ", " + x.GetPath().GetString() + ")";
}
std::string __Overlay::to_string(const pxr::SdfDictionaryProxy& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::SdfRelocatesMapProxy& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::SdfChangeList& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::SdfChangeList::SubLayerChangeType& x) {
    switch (x) {
    case pxr::SdfChangeList::SubLayerAdded: return "pxr::SdfChangeList::SubLayerAdded";
    case pxr::SdfChangeList::SubLayerRemoved: return "pxr::SdfChangeList::SubLayerRemoved";
    case pxr::SdfChangeList::SubLayerOffset: return "pxr::SdfChangeList::SubLayerOffset";
    default: return "pxr::SdfChangeList::SubLayerChangeType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::SdfLayerOffset& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::SdfNamespaceEdit& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::SdfNamespaceEditDetail& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::SdfNamespaceEditDetail::Result& x) {
    switch (x) {
    case pxr::SdfNamespaceEditDetail::Error: return "pxr::SdfNamespaceEditDetail::Error";
    case pxr::SdfNamespaceEditDetail::Unbatched: return "pxr::SdfNamespaceEditDetail::Unbatched";
    case pxr::SdfNamespaceEditDetail::Okay: return "pxr::SdfNamespaceEditDetail::Okay";
    default: return "pxr::SdfNamespaceEditDetail::Result(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::SdfPredicateFunctionResult::Constancy& x) {
    switch (x) {
    case pxr::SdfPredicateFunctionResult::ConstantOverDescendants: return "pxr::SdfPredicateFunctionResult::ConstantOverDescendants";
    case pxr::SdfPredicateFunctionResult::MayVaryOverDescendants: return "pxr::SdfPredicateFunctionResult::MayVaryOverDescendants";
    default: return "pxr::SdfPredicateFunctionResult::Constancy(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::SdfPayload& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::SdfPrimSpecHandle& x) {
    if (!x) {
        return "expired pxr::SdfPrimSpecHandle";
    }
    return "pxr::SdfPrimSpecHandle(" + __Overlay::to_string(x.GetSpec()) + ")";
}
std::string __Overlay::to_string(const pxr::SdfPrimSpec& x) {
    if (x.IsDormant()) {
        return "dormant pxr::SdfPrimSpec";
    }
    return "pxr::SdfPrimSpec(" + x.GetLayer()->GetIdentifier() + ", " + x.GetPath().GetString() + ")";
}
std::string __Overlay::to_string(const pxr::SdfPseudoRootSpec& x) {
    if (x.IsDormant()) {
        return "dormant pxr::SdfPseudoRootSpec";
    }
    return "pxr::SdfPseudoRootSpec(" + x.GetLayer()->GetIdentifier() + ", " + x.GetPath().GetString() + ")";
}
std::string __Overlay::to_string(const pxr::SdfReference& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::SdfRelationshipSpecHandle& x) {
    if (!x) {
        return "expired pxr::SdfRelationshipSpecHandle";
    }
    return "pxr::SdfRelationshipSpecHandle(" + __Overlay::to_string(x.GetSpec()) + ")";
}
std::string __Overlay::to_string(const pxr::SdfRelationshipSpec& x) {
    if (x.IsDormant()) {
        return "dormant pxr::SdfRelationshipSpec";
    }
    return "pxr::SdfRelationshipSpec(" + x.GetLayer()->GetIdentifier() + ", " + x.GetPath().GetString() + ")";
}
std::string __Overlay::to_string(const pxr::SdfVariantSetSpecHandle& x) {
    if (!x) {
        return "expired pxr::SdfVariantSetSpecHandle";
    }
    return "pxr::SdfVariantSetSpecHandle(" + __Overlay::to_string(x.GetSpec()) + ")";
}
std::string __Overlay::to_string(const pxr::SdfVariantSetSpec& x) {
    if (x.IsDormant()) {
        return "dormant pxr::SdfVariantSetSpec";
    }
    return "pxr::SdfVariantSetSpec(" + x.GetLayer()->GetIdentifier() + ", " + x.GetPath().GetString() + ")";
}
std::string __Overlay::to_string(const pxr::SdfVariantSpecHandle& x) {
    if (!x) {
        return "expired pxr::SdfVariantSpecHandle";
    }
    return "pxr::SdfVariantSpecHandle(" + __Overlay::to_string(x.GetSpec()) + ")";
}
std::string __Overlay::to_string(const pxr::SdfVariantSpec& x) {
    if (x.IsDormant()) {
        return "dormant pxr::SdfVariantSpec";
    }
    return "pxr::SdfVariantSpec(" + x.GetLayer()->GetIdentifier() + ", " + x.GetPath().GetString() + ")";
}
std::string __Overlay::to_string(const pxr::SdrVersionFilter& x) {
    switch (x) {
    case pxr::SdrVersionFilterDefaultOnly: return "pxr::SdrVersionFilterDefaultOnly";
    case pxr::SdrVersionFilterAllVersions: return "pxr::SdrVersionFilterAllVersions";
    case pxr::SdrNumVersionFilters: return "pxr::SdrNumVersionFilters";
    default: return "pxr::SdrVersionFilter(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::PcpNodeRef& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::PcpArcType& x) {
    switch (x) {
    case pxr::PcpArcTypeRoot: return "pxr::PcpArcTypeRoot";
    case pxr::PcpArcTypeInherit: return "pxr::PcpArcTypeInherit";
    case pxr::PcpArcTypeVariant: return "pxr::PcpArcTypeVariant";
    case pxr::PcpArcTypeRelocate: return "pxr::PcpArcTypeRelocate";
    case pxr::PcpArcTypeReference: return "pxr::PcpArcTypeReference";
    case pxr::PcpArcTypePayload: return "pxr::PcpArcTypePayload";
    case pxr::PcpArcTypeSpecialize: return "pxr::PcpArcTypeSpecialize";
    case pxr::PcpNumArcTypes: return "pxr::PcpNumArcTypes";
    default: return "pxr::PcpArcType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::PcpRangeType& x) {
    switch (x) {
    case pxr::PcpRangeTypeRoot: return "pxr::PcpRangeTypeRoot";
    case pxr::PcpRangeTypeInherit: return "pxr::PcpRangeTypeInherit";
    case pxr::PcpRangeTypeVariant: return "pxr::PcpRangeTypeVariant";
    case pxr::PcpRangeTypeReference: return "pxr::PcpRangeTypeReference";
    case pxr::PcpRangeTypePayload: return "pxr::PcpRangeTypePayload";
    case pxr::PcpRangeTypeSpecialize: return "pxr::PcpRangeTypeSpecialize";
    case pxr::PcpRangeTypeAll: return "pxr::PcpRangeTypeAll";
    case pxr::PcpRangeTypeWeakerThanRoot: return "pxr::PcpRangeTypeWeakerThanRoot";
    case pxr::PcpRangeTypeStrongerThanPayload: return "pxr::PcpRangeTypeStrongerThanPayload";
    case pxr::PcpRangeTypeInvalid: return "pxr::PcpRangeTypeInvalid";
    default: return "pxr::PcpRangeType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::PcpSite& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::PcpLayerStackSite& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::PcpLayerStackIdentifier& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::PcpDependencyType& x) {
    switch (x) {
    case pxr::PcpDependencyTypeNone: return "pxr::PcpDependencyTypeNone";
    case pxr::PcpDependencyTypeRoot: return "pxr::PcpDependencyTypeRoot";
    case pxr::PcpDependencyTypePurelyDirect: return "pxr::PcpDependencyTypePurelyDirect";
    case pxr::PcpDependencyTypePartlyDirect: return "pxr::PcpDependencyTypePartlyDirect";
    case pxr::PcpDependencyTypeAncestral: return "pxr::PcpDependencyTypeAncestral";
    case pxr::PcpDependencyTypeVirtual: return "pxr::PcpDependencyTypeVirtual";
    case pxr::PcpDependencyTypeNonVirtual: return "pxr::PcpDependencyTypeNonVirtual";
    case pxr::PcpDependencyTypeDirect: return "pxr::PcpDependencyTypeDirect";
    case pxr::PcpDependencyTypeAnyNonVirtual: return "pxr::PcpDependencyTypeAnyNonVirtual";
    case pxr::PcpDependencyTypeAnyIncludingVirtual: return "pxr::PcpDependencyTypeAnyIncludingVirtual";
    default: return "pxr::PcpDependencyType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::PcpErrorType& x) {
    switch (x) {
    case pxr::PcpErrorType_ArcCycle: return "pxr::PcpErrorType_ArcCycle";
    case pxr::PcpErrorType_ArcPermissionDenied: return "pxr::PcpErrorType_ArcPermissionDenied";
    case pxr::PcpErrorType_ArcToProhibitedChild: return "pxr::PcpErrorType_ArcToProhibitedChild";
    case pxr::PcpErrorType_IndexCapacityExceeded: return "pxr::PcpErrorType_IndexCapacityExceeded";
    case pxr::PcpErrorType_ArcCapacityExceeded: return "pxr::PcpErrorType_ArcCapacityExceeded";
    case pxr::PcpErrorType_ArcNamespaceDepthCapacityExceeded: return "pxr::PcpErrorType_ArcNamespaceDepthCapacityExceeded";
    case pxr::PcpErrorType_InconsistentPropertyType: return "pxr::PcpErrorType_InconsistentPropertyType";
    case pxr::PcpErrorType_InconsistentAttributeType: return "pxr::PcpErrorType_InconsistentAttributeType";
    case pxr::PcpErrorType_InconsistentAttributeVariability: return "pxr::PcpErrorType_InconsistentAttributeVariability";
    case pxr::PcpErrorType_InternalAssetPath: return "pxr::PcpErrorType_InternalAssetPath";
    case pxr::PcpErrorType_InvalidPrimPath: return "pxr::PcpErrorType_InvalidPrimPath";
    case pxr::PcpErrorType_InvalidAssetPath: return "pxr::PcpErrorType_InvalidAssetPath";
    case pxr::PcpErrorType_InvalidInstanceTargetPath: return "pxr::PcpErrorType_InvalidInstanceTargetPath";
    case pxr::PcpErrorType_InvalidExternalTargetPath: return "pxr::PcpErrorType_InvalidExternalTargetPath";
    case pxr::PcpErrorType_InvalidTargetPath: return "pxr::PcpErrorType_InvalidTargetPath";
    case pxr::PcpErrorType_InvalidReferenceOffset: return "pxr::PcpErrorType_InvalidReferenceOffset";
    case pxr::PcpErrorType_InvalidSublayerOffset: return "pxr::PcpErrorType_InvalidSublayerOffset";
    case pxr::PcpErrorType_InvalidSublayerOwnership: return "pxr::PcpErrorType_InvalidSublayerOwnership";
    case pxr::PcpErrorType_InvalidSublayerPath: return "pxr::PcpErrorType_InvalidSublayerPath";
    case pxr::PcpErrorType_InvalidVariantSelection: return "pxr::PcpErrorType_InvalidVariantSelection";
    case pxr::PcpErrorType_MutedAssetPath: return "pxr::PcpErrorType_MutedAssetPath";
    case pxr::PcpErrorType_InvalidAuthoredRelocation: return "pxr::PcpErrorType_InvalidAuthoredRelocation";
    case pxr::PcpErrorType_InvalidConflictingRelocation: return "pxr::PcpErrorType_InvalidConflictingRelocation";
    case pxr::PcpErrorType_InvalidSameTargetRelocations: return "pxr::PcpErrorType_InvalidSameTargetRelocations";
    case pxr::PcpErrorType_OpinionAtRelocationSource: return "pxr::PcpErrorType_OpinionAtRelocationSource";
    case pxr::PcpErrorType_PrimPermissionDenied: return "pxr::PcpErrorType_PrimPermissionDenied";
    case pxr::PcpErrorType_PropertyPermissionDenied: return "pxr::PcpErrorType_PropertyPermissionDenied";
    case pxr::PcpErrorType_SublayerCycle: return "pxr::PcpErrorType_SublayerCycle";
    case pxr::PcpErrorType_TargetPermissionDenied: return "pxr::PcpErrorType_TargetPermissionDenied";
    case pxr::PcpErrorType_UnresolvedPrimPath: return "pxr::PcpErrorType_UnresolvedPrimPath";
    case pxr::PcpErrorType_VariableExpressionError: return "pxr::PcpErrorType_VariableExpressionError";
    default: return "pxr::PcpErrorType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::PcpErrorInvalidConflictingRelocation::ConflictReason& x) {
    switch (x) {
    case pxr::PcpErrorInvalidConflictingRelocation::ConflictReason::TargetIsConflictSource: return "pxr::PcpErrorInvalidConflictingRelocation::ConflictReason::TargetIsConflictSource";
    case pxr::PcpErrorInvalidConflictingRelocation::ConflictReason::SourceIsConflictTarget: return "pxr::PcpErrorInvalidConflictingRelocation::ConflictReason::SourceIsConflictTarget";
    case pxr::PcpErrorInvalidConflictingRelocation::ConflictReason::TargetIsConflictSourceDescendant: return "pxr::PcpErrorInvalidConflictingRelocation::ConflictReason::TargetIsConflictSourceDescendant";
    case pxr::PcpErrorInvalidConflictingRelocation::ConflictReason::SourceIsConflictSourceDescendant: return "pxr::PcpErrorInvalidConflictingRelocation::ConflictReason::SourceIsConflictSourceDescendant";
    default: return "pxr::PcpErrorInvalidConflictingRelocation::ConflictReason(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::PcpPrimIndexOutputs::PayloadState& x) {
    switch (x) {
    case pxr::PcpPrimIndexOutputs::NoPayload: return "pxr::PcpPrimIndexOutputs::NoPayload";
    case pxr::PcpPrimIndexOutputs::IncludedByIncludeSet: return "pxr::PcpPrimIndexOutputs::IncludedByIncludeSet";
    case pxr::PcpPrimIndexOutputs::ExcludedByIncludeSet: return "pxr::PcpPrimIndexOutputs::ExcludedByIncludeSet";
    case pxr::PcpPrimIndexOutputs::IncludedByPredicate: return "pxr::PcpPrimIndexOutputs::IncludedByPredicate";
    case pxr::PcpPrimIndexOutputs::ExcludedByPredicate: return "pxr::PcpPrimIndexOutputs::ExcludedByPredicate";
    default: return "pxr::PcpPrimIndexOutputs::PayloadState(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::PcpCacheChanges::TargetType& x) {
    switch (x) {
    case pxr::PcpCacheChanges::TargetTypeConnection: return "pxr::PcpCacheChanges::TargetTypeConnection";
    case pxr::PcpCacheChanges::TargetTypeRelationshipTarget: return "pxr::PcpCacheChanges::TargetTypeRelationshipTarget";
    default: return "pxr::PcpCacheChanges::TargetType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::PcpChanges::ChangeSpecsType& x) {
    switch (x) {
    case pxr::PcpChanges::ChangeSpecsTypeRemoved: return "pxr::PcpChanges::ChangeSpecsTypeRemoved";
    case pxr::PcpChanges::ChangeSpecsTypeAdded: return "pxr::PcpChanges::ChangeSpecsTypeAdded";
    default: return "pxr::PcpChanges::ChangeSpecsType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::PcpLayerStackRefPtr& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::PcpLayerStackPtr& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::PcpNamespaceEdits::EditType& x) {
    switch (x) {
    case pxr::PcpNamespaceEdits::EditPath: return "pxr::PcpNamespaceEdits::EditPath";
    case pxr::PcpNamespaceEdits::EditInherit: return "pxr::PcpNamespaceEdits::EditInherit";
    case pxr::PcpNamespaceEdits::EditSpecializes: return "pxr::PcpNamespaceEdits::EditSpecializes";
    case pxr::PcpNamespaceEdits::EditReference: return "pxr::PcpNamespaceEdits::EditReference";
    case pxr::PcpNamespaceEdits::EditPayload: return "pxr::PcpNamespaceEdits::EditPayload";
    case pxr::PcpNamespaceEdits::EditRelocate: return "pxr::PcpNamespaceEdits::EditRelocate";
    default: return "pxr::PcpNamespaceEdits::EditType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::UsdPrim& x) {
    return x.GetDescription();
}
std::string __Overlay::to_string(const pxr::UsdListPosition& x) {
    switch (x) {
    case pxr::UsdListPositionFrontOfPrependList: return "pxr::UsdListPositionFrontOfPrependList";
    case pxr::UsdListPositionBackOfPrependList: return "pxr::UsdListPositionBackOfPrependList";
    case pxr::UsdListPositionFrontOfAppendList: return "pxr::UsdListPositionFrontOfAppendList";
    case pxr::UsdListPositionBackOfAppendList: return "pxr::UsdListPositionBackOfAppendList";
    default: return "pxr::UsdListPosition(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::UsdLoadPolicy& x) {
    switch (x) {
    case pxr::UsdLoadWithDescendants: return "pxr::UsdLoadWithDescendants";
    case pxr::UsdLoadWithoutDescendants: return "pxr::UsdLoadWithoutDescendants";
    default: return "pxr::UsdLoadPolicy(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::UsdSchemaKind& x) {
    switch (x) {
    case pxr::UsdSchemaKind::Invalid: return "pxr::UsdSchemaKind::Invalid";
    case pxr::UsdSchemaKind::AbstractBase: return "pxr::UsdSchemaKind::AbstractBase";
    case pxr::UsdSchemaKind::AbstractTyped: return "pxr::UsdSchemaKind::AbstractTyped";
    case pxr::UsdSchemaKind::ConcreteTyped: return "pxr::UsdSchemaKind::ConcreteTyped";
    case pxr::UsdSchemaKind::NonAppliedAPI: return "pxr::UsdSchemaKind::NonAppliedAPI";
    case pxr::UsdSchemaKind::SingleApplyAPI: return "pxr::UsdSchemaKind::SingleApplyAPI";
    case pxr::UsdSchemaKind::MultipleApplyAPI: return "pxr::UsdSchemaKind::MultipleApplyAPI";
    default: return "pxr::UsdSchemaKind(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::UsdTimeCode& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::UsdObjType& x) {
    switch (x) {
    case pxr::UsdTypeObject: return "pxr::UsdTypeObject";
    case pxr::UsdTypePrim: return "pxr::UsdTypePrim";
    case pxr::UsdTypeProperty: return "pxr::UsdTypeProperty";
    case pxr::UsdTypeAttribute: return "pxr::UsdTypeAttribute";
    case pxr::UsdTypeRelationship: return "pxr::UsdTypeRelationship";
    case pxr::Usd_NumObjTypes: return "pxr::Usd_NumObjTypes";
    default: return "pxr::UsdObjType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::UsdObject& x) {
    return x.GetDescription();
}
std::string __Overlay::to_string(const pxr::UsdSchemaRegistry::VersionPolicy& x) {
    switch (x) {
    case pxr::UsdSchemaRegistry::VersionPolicy::All: return "pxr::UsdSchemaRegistry::VersionPolicy::All";
    case pxr::UsdSchemaRegistry::VersionPolicy::GreaterThan: return "pxr::UsdSchemaRegistry::VersionPolicy::GreaterThan";
    case pxr::UsdSchemaRegistry::VersionPolicy::GreaterThanOrEqual: return "pxr::UsdSchemaRegistry::VersionPolicy::GreaterThanOrEqual";
    case pxr::UsdSchemaRegistry::VersionPolicy::LessThan: return "pxr::UsdSchemaRegistry::VersionPolicy::LessThan";
    case pxr::UsdSchemaRegistry::VersionPolicy::LessThanOrEqual: return "pxr::UsdSchemaRegistry::VersionPolicy::LessThanOrEqual";
    default: return "pxr::UsdSchemaRegistry::VersionPolicy(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::UsdStage::InitialLoadSet& x) {
    switch (x) {
    case pxr::UsdStage::LoadAll: return "pxr::UsdStage::LoadAll";
    case pxr::UsdStage::LoadNone: return "pxr::UsdStage::LoadNone";
    default: return "pxr::UsdStage::InitialLoadSet(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::UsdInterpolationType& x) {
    switch (x) {
    case pxr::UsdInterpolationTypeHeld: return "pxr::UsdInterpolationTypeHeld";
    case pxr::UsdInterpolationTypeLinear: return "pxr::UsdInterpolationTypeLinear";
    default: return "pxr::UsdInterpolationType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::UsdStageLoadRules& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::UsdStageLoadRules::Rule& x) {
    switch (x) {
    case pxr::UsdStageLoadRules::AllRule: return "pxr::UsdStageLoadRules::AllRule";
    case pxr::UsdStageLoadRules::OnlyRule: return "pxr::UsdStageLoadRules::OnlyRule";
    case pxr::UsdStageLoadRules::NoneRule: return "pxr::UsdStageLoadRules::NoneRule";
    default: return "pxr::UsdStageLoadRules::Rule(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::UsdStagePopulationMask& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::UsdAttribute& x) {
    return x.GetDescription();
}
std::string __Overlay::to_string(const pxr::UsdProperty& x) {
    return x.GetDescription();
}
std::string __Overlay::to_string(const pxr::UsdResolveInfoSource& x) {
    switch (x) {
    case pxr::UsdResolveInfoSourceNone: return "pxr::UsdResolveInfoSourceNone";
    case pxr::UsdResolveInfoSourceFallback: return "pxr::UsdResolveInfoSourceFallback";
    case pxr::UsdResolveInfoSourceDefault: return "pxr::UsdResolveInfoSourceDefault";
    case pxr::UsdResolveInfoSourceTimeSamples: return "pxr::UsdResolveInfoSourceTimeSamples";
    case pxr::UsdResolveInfoSourceValueClips: return "pxr::UsdResolveInfoSourceValueClips";
    case pxr::UsdResolveInfoSourceSpline: return "pxr::UsdResolveInfoSourceSpline";
    default: return "pxr::UsdResolveInfoSource(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::UsdRelationship& x) {
    return x.GetDescription();
}
std::string __Overlay::to_string(const pxr::UsdModelAPI::KindValidation& x) {
    switch (x) {
    case pxr::UsdModelAPI::KindValidationNone: return "pxr::UsdModelAPI::KindValidationNone";
    case pxr::UsdModelAPI::KindValidationModelHierarchy: return "pxr::UsdModelAPI::KindValidationModelHierarchy";
    default: return "pxr::UsdModelAPI::KindValidation(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::UsdNotice::ObjectsChanged::PrimResyncType& x) {
    switch (x) {
    case pxr::UsdNotice::ObjectsChanged::PrimResyncType::RenameSource: return "pxr::UsdNotice::ObjectsChanged::PrimResyncType::RenameSource";
    case pxr::UsdNotice::ObjectsChanged::PrimResyncType::RenameDestination: return "pxr::UsdNotice::ObjectsChanged::PrimResyncType::RenameDestination";
    case pxr::UsdNotice::ObjectsChanged::PrimResyncType::ReparentSource: return "pxr::UsdNotice::ObjectsChanged::PrimResyncType::ReparentSource";
    case pxr::UsdNotice::ObjectsChanged::PrimResyncType::ReparentDestination: return "pxr::UsdNotice::ObjectsChanged::PrimResyncType::ReparentDestination";
    case pxr::UsdNotice::ObjectsChanged::PrimResyncType::RenameAndReparentSource: return "pxr::UsdNotice::ObjectsChanged::PrimResyncType::RenameAndReparentSource";
    case pxr::UsdNotice::ObjectsChanged::PrimResyncType::RenameAndReparentDestination: return "pxr::UsdNotice::ObjectsChanged::PrimResyncType::RenameAndReparentDestination";
    case pxr::UsdNotice::ObjectsChanged::PrimResyncType::Delete: return "pxr::UsdNotice::ObjectsChanged::PrimResyncType::Delete";
    case pxr::UsdNotice::ObjectsChanged::PrimResyncType::UnchangedPrimStack: return "pxr::UsdNotice::ObjectsChanged::PrimResyncType::UnchangedPrimStack";
    case pxr::UsdNotice::ObjectsChanged::PrimResyncType::Other: return "pxr::UsdNotice::ObjectsChanged::PrimResyncType::Other";
    case pxr::UsdNotice::ObjectsChanged::PrimResyncType::Invalid: return "pxr::UsdNotice::ObjectsChanged::PrimResyncType::Invalid";
    default: return "pxr::UsdNotice::ObjectsChanged::PrimResyncType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::UsdPrimCompositionQuery::ArcTypeFilter& x) {
    switch (x) {
    case pxr::UsdPrimCompositionQuery::ArcTypeFilter::All: return "pxr::UsdPrimCompositionQuery::ArcTypeFilter::All";
    case pxr::UsdPrimCompositionQuery::ArcTypeFilter::Reference: return "pxr::UsdPrimCompositionQuery::ArcTypeFilter::Reference";
    case pxr::UsdPrimCompositionQuery::ArcTypeFilter::Payload: return "pxr::UsdPrimCompositionQuery::ArcTypeFilter::Payload";
    case pxr::UsdPrimCompositionQuery::ArcTypeFilter::Inherit: return "pxr::UsdPrimCompositionQuery::ArcTypeFilter::Inherit";
    case pxr::UsdPrimCompositionQuery::ArcTypeFilter::Specialize: return "pxr::UsdPrimCompositionQuery::ArcTypeFilter::Specialize";
    case pxr::UsdPrimCompositionQuery::ArcTypeFilter::Variant: return "pxr::UsdPrimCompositionQuery::ArcTypeFilter::Variant";
    case pxr::UsdPrimCompositionQuery::ArcTypeFilter::ReferenceOrPayload: return "pxr::UsdPrimCompositionQuery::ArcTypeFilter::ReferenceOrPayload";
    case pxr::UsdPrimCompositionQuery::ArcTypeFilter::InheritOrSpecialize: return "pxr::UsdPrimCompositionQuery::ArcTypeFilter::InheritOrSpecialize";
    case pxr::UsdPrimCompositionQuery::ArcTypeFilter::NotReferenceOrPayload: return "pxr::UsdPrimCompositionQuery::ArcTypeFilter::NotReferenceOrPayload";
    case pxr::UsdPrimCompositionQuery::ArcTypeFilter::NotInheritOrSpecialize: return "pxr::UsdPrimCompositionQuery::ArcTypeFilter::NotInheritOrSpecialize";
    case pxr::UsdPrimCompositionQuery::ArcTypeFilter::NotVariant: return "pxr::UsdPrimCompositionQuery::ArcTypeFilter::NotVariant";
    default: return "pxr::UsdPrimCompositionQuery::ArcTypeFilter(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::UsdPrimCompositionQuery::DependencyTypeFilter& x) {
    switch (x) {
    case pxr::UsdPrimCompositionQuery::DependencyTypeFilter::All: return "pxr::UsdPrimCompositionQuery::DependencyTypeFilter::All";
    case pxr::UsdPrimCompositionQuery::DependencyTypeFilter::Direct: return "pxr::UsdPrimCompositionQuery::DependencyTypeFilter::Direct";
    case pxr::UsdPrimCompositionQuery::DependencyTypeFilter::Ancestral: return "pxr::UsdPrimCompositionQuery::DependencyTypeFilter::Ancestral";
    default: return "pxr::UsdPrimCompositionQuery::DependencyTypeFilter(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::UsdPrimCompositionQuery::ArcIntroducedFilter& x) {
    switch (x) {
    case pxr::UsdPrimCompositionQuery::ArcIntroducedFilter::All: return "pxr::UsdPrimCompositionQuery::ArcIntroducedFilter::All";
    case pxr::UsdPrimCompositionQuery::ArcIntroducedFilter::IntroducedInRootLayerStack: return "pxr::UsdPrimCompositionQuery::ArcIntroducedFilter::IntroducedInRootLayerStack";
    case pxr::UsdPrimCompositionQuery::ArcIntroducedFilter::IntroducedInRootLayerPrimSpec: return "pxr::UsdPrimCompositionQuery::ArcIntroducedFilter::IntroducedInRootLayerPrimSpec";
    default: return "pxr::UsdPrimCompositionQuery::ArcIntroducedFilter(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::UsdPrimCompositionQuery::HasSpecsFilter& x) {
    switch (x) {
    case pxr::UsdPrimCompositionQuery::HasSpecsFilter::All: return "pxr::UsdPrimCompositionQuery::HasSpecsFilter::All";
    case pxr::UsdPrimCompositionQuery::HasSpecsFilter::HasSpecs: return "pxr::UsdPrimCompositionQuery::HasSpecsFilter::HasSpecs";
    case pxr::UsdPrimCompositionQuery::HasSpecsFilter::HasNoSpecs: return "pxr::UsdPrimCompositionQuery::HasSpecsFilter::HasNoSpecs";
    default: return "pxr::UsdPrimCompositionQuery::HasSpecsFilter(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::UsdStageCacheContextBlockType& x) {
    switch (x) {
    case pxr::UsdBlockStageCaches: return "pxr::UsdBlockStageCaches";
    case pxr::UsdBlockStageCachePopulation: return "pxr::UsdBlockStageCachePopulation";
    case pxr::Usd_NoBlock: return "pxr::Usd_NoBlock";
    default: return "pxr::UsdStageCacheContextBlockType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::UsdGeomXformOp& x) {
    return "pxr::UsdGeomXformOp(" + x.GetAttr().GetPath().GetString() + ")";
}
std::string __Overlay::to_string(const pxr::UsdGeomXformOp::Type& x) {
    switch (x) {
    case pxr::UsdGeomXformOp::TypeInvalid: return "pxr::UsdGeomXformOp::TypeInvalid";
    case pxr::UsdGeomXformOp::TypeTranslateX: return "pxr::UsdGeomXformOp::TypeTranslateX";
    case pxr::UsdGeomXformOp::TypeTranslateY: return "pxr::UsdGeomXformOp::TypeTranslateY";
    case pxr::UsdGeomXformOp::TypeTranslateZ: return "pxr::UsdGeomXformOp::TypeTranslateZ";
    case pxr::UsdGeomXformOp::TypeTranslate: return "pxr::UsdGeomXformOp::TypeTranslate";
    case pxr::UsdGeomXformOp::TypeScaleX: return "pxr::UsdGeomXformOp::TypeScaleX";
    case pxr::UsdGeomXformOp::TypeScaleY: return "pxr::UsdGeomXformOp::TypeScaleY";
    case pxr::UsdGeomXformOp::TypeScaleZ: return "pxr::UsdGeomXformOp::TypeScaleZ";
    case pxr::UsdGeomXformOp::TypeScale: return "pxr::UsdGeomXformOp::TypeScale";
    case pxr::UsdGeomXformOp::TypeRotateX: return "pxr::UsdGeomXformOp::TypeRotateX";
    case pxr::UsdGeomXformOp::TypeRotateY: return "pxr::UsdGeomXformOp::TypeRotateY";
    case pxr::UsdGeomXformOp::TypeRotateZ: return "pxr::UsdGeomXformOp::TypeRotateZ";
    case pxr::UsdGeomXformOp::TypeRotateXYZ: return "pxr::UsdGeomXformOp::TypeRotateXYZ";
    case pxr::UsdGeomXformOp::TypeRotateXZY: return "pxr::UsdGeomXformOp::TypeRotateXZY";
    case pxr::UsdGeomXformOp::TypeRotateYXZ: return "pxr::UsdGeomXformOp::TypeRotateYXZ";
    case pxr::UsdGeomXformOp::TypeRotateYZX: return "pxr::UsdGeomXformOp::TypeRotateYZX";
    case pxr::UsdGeomXformOp::TypeRotateZXY: return "pxr::UsdGeomXformOp::TypeRotateZXY";
    case pxr::UsdGeomXformOp::TypeRotateZYX: return "pxr::UsdGeomXformOp::TypeRotateZYX";
    case pxr::UsdGeomXformOp::TypeOrient: return "pxr::UsdGeomXformOp::TypeOrient";
    case pxr::UsdGeomXformOp::TypeTransform: return "pxr::UsdGeomXformOp::TypeTransform";
    default: return "pxr::UsdGeomXformOp::Type(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::UsdGeomXformOp::Precision& x) {
    switch (x) {
    case pxr::UsdGeomXformOp::PrecisionDouble: return "pxr::UsdGeomXformOp::PrecisionDouble";
    case pxr::UsdGeomXformOp::PrecisionFloat: return "pxr::UsdGeomXformOp::PrecisionFloat";
    case pxr::UsdGeomXformOp::PrecisionHalf: return "pxr::UsdGeomXformOp::PrecisionHalf";
    default: return "pxr::UsdGeomXformOp::Precision(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::UsdGeomPointInstancer::ProtoXformInclusion& x) {
    switch (x) {
    case pxr::UsdGeomPointInstancer::IncludeProtoXform: return "pxr::UsdGeomPointInstancer::IncludeProtoXform";
    case pxr::UsdGeomPointInstancer::ExcludeProtoXform: return "pxr::UsdGeomPointInstancer::ExcludeProtoXform";
    default: return "pxr::UsdGeomPointInstancer::ProtoXformInclusion(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::UsdGeomPointInstancer::MaskApplication& x) {
    switch (x) {
    case pxr::UsdGeomPointInstancer::ApplyMask: return "pxr::UsdGeomPointInstancer::ApplyMask";
    case pxr::UsdGeomPointInstancer::IgnoreMask: return "pxr::UsdGeomPointInstancer::IgnoreMask";
    default: return "pxr::UsdGeomPointInstancer::MaskApplication(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::UsdGeomXformCommonAPI::RotationOrder& x) {
    switch (x) {
    case pxr::UsdGeomXformCommonAPI::RotationOrderXYZ: return "pxr::UsdGeomXformCommonAPI::RotationOrderXYZ";
    case pxr::UsdGeomXformCommonAPI::RotationOrderXZY: return "pxr::UsdGeomXformCommonAPI::RotationOrderXZY";
    case pxr::UsdGeomXformCommonAPI::RotationOrderYXZ: return "pxr::UsdGeomXformCommonAPI::RotationOrderYXZ";
    case pxr::UsdGeomXformCommonAPI::RotationOrderYZX: return "pxr::UsdGeomXformCommonAPI::RotationOrderYZX";
    case pxr::UsdGeomXformCommonAPI::RotationOrderZXY: return "pxr::UsdGeomXformCommonAPI::RotationOrderZXY";
    case pxr::UsdGeomXformCommonAPI::RotationOrderZYX: return "pxr::UsdGeomXformCommonAPI::RotationOrderZYX";
    default: return "pxr::UsdGeomXformCommonAPI::RotationOrder(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::UsdGeomXformCommonAPI::OpFlags& x) {
    switch (x) {
    case pxr::UsdGeomXformCommonAPI::OpNone: return "pxr::UsdGeomXformCommonAPI::OpNone";
    case pxr::UsdGeomXformCommonAPI::OpTranslate: return "pxr::UsdGeomXformCommonAPI::OpTranslate";
    case pxr::UsdGeomXformCommonAPI::OpPivot: return "pxr::UsdGeomXformCommonAPI::OpPivot";
    case pxr::UsdGeomXformCommonAPI::OpRotate: return "pxr::UsdGeomXformCommonAPI::OpRotate";
    case pxr::UsdGeomXformCommonAPI::OpScale: return "pxr::UsdGeomXformCommonAPI::OpScale";
    default: return "pxr::UsdGeomXformCommonAPI::OpFlags(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::UsdShadeAttributeType& x) {
    switch (x) {
    case pxr::UsdShadeAttributeType::Invalid: return "pxr::UsdShadeAttributeType::Invalid";
    case pxr::UsdShadeAttributeType::Input: return "pxr::UsdShadeAttributeType::Input";
    case pxr::UsdShadeAttributeType::Output: return "pxr::UsdShadeAttributeType::Output";
    default: return "pxr::UsdShadeAttributeType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::UsdShadeConnectionModification& x) {
    switch (x) {
    case pxr::UsdShadeConnectionModification::Replace: return "pxr::UsdShadeConnectionModification::Replace";
    case pxr::UsdShadeConnectionModification::Prepend: return "pxr::UsdShadeConnectionModification::Prepend";
    case pxr::UsdShadeConnectionModification::Append: return "pxr::UsdShadeConnectionModification::Append";
    default: return "pxr::UsdShadeConnectionModification(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::UsdShadeConnectableAPIBehavior::ConnectableNodeTypes& x) {
    switch (x) {
    case pxr::UsdShadeConnectableAPIBehavior::BasicNodes: return "pxr::UsdShadeConnectableAPIBehavior::BasicNodes";
    case pxr::UsdShadeConnectableAPIBehavior::DerivedContainerNodes: return "pxr::UsdShadeConnectableAPIBehavior::DerivedContainerNodes";
    default: return "pxr::UsdShadeConnectableAPIBehavior::ConnectableNodeTypes(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::UsdLuxLightListAPI::ComputeMode& x) {
    switch (x) {
    case pxr::UsdLuxLightListAPI::ComputeModeConsultModelHierarchyCache: return "pxr::UsdLuxLightListAPI::ComputeModeConsultModelHierarchyCache";
    case pxr::UsdLuxLightListAPI::ComputeModeIgnoreCache: return "pxr::UsdLuxLightListAPI::ComputeModeIgnoreCache";
    default: return "pxr::UsdLuxLightListAPI::ComputeMode(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::UsdLuxListAPI::ComputeMode& x) {
    switch (x) {
    case pxr::UsdLuxListAPI::ComputeModeConsultModelHierarchyCache: return "pxr::UsdLuxListAPI::ComputeModeConsultModelHierarchyCache";
    case pxr::UsdLuxListAPI::ComputeModeIgnoreCache: return "pxr::UsdLuxListAPI::ComputeModeIgnoreCache";
    default: return "pxr::UsdLuxListAPI::ComputeMode(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::UsdSkelBakeSkinningParms::DeformationFlags& x) {
    switch (x) {
    case pxr::UsdSkelBakeSkinningParms::DeformPointsWithSkinning: return "pxr::UsdSkelBakeSkinningParms::DeformPointsWithSkinning";
    case pxr::UsdSkelBakeSkinningParms::DeformNormalsWithSkinning: return "pxr::UsdSkelBakeSkinningParms::DeformNormalsWithSkinning";
    case pxr::UsdSkelBakeSkinningParms::DeformXformWithSkinning: return "pxr::UsdSkelBakeSkinningParms::DeformXformWithSkinning";
    case pxr::UsdSkelBakeSkinningParms::DeformPointsWithBlendShapes: return "pxr::UsdSkelBakeSkinningParms::DeformPointsWithBlendShapes";
    case pxr::UsdSkelBakeSkinningParms::DeformNormalsWithBlendShapes: return "pxr::UsdSkelBakeSkinningParms::DeformNormalsWithBlendShapes";
    case pxr::UsdSkelBakeSkinningParms::DeformWithSkinning: return "pxr::UsdSkelBakeSkinningParms::DeformWithSkinning";
    case pxr::UsdSkelBakeSkinningParms::DeformWithBlendShapes: return "pxr::UsdSkelBakeSkinningParms::DeformWithBlendShapes";
    case pxr::UsdSkelBakeSkinningParms::DeformAll: return "pxr::UsdSkelBakeSkinningParms::DeformAll";
    case pxr::UsdSkelBakeSkinningParms::ModifiesPoints: return "pxr::UsdSkelBakeSkinningParms::ModifiesPoints";
    case pxr::UsdSkelBakeSkinningParms::ModifiesNormals: return "pxr::UsdSkelBakeSkinningParms::ModifiesNormals";
    default: return "pxr::UsdSkelBakeSkinningParms::DeformationFlags(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::UsdUtilsRegisteredVariantSet::SelectionExportPolicy& x) {
    switch (x) {
    case pxr::UsdUtilsRegisteredVariantSet::SelectionExportPolicy::Never: return "pxr::UsdUtilsRegisteredVariantSet::SelectionExportPolicy::Never";
    case pxr::UsdUtilsRegisteredVariantSet::SelectionExportPolicy::IfAuthored: return "pxr::UsdUtilsRegisteredVariantSet::SelectionExportPolicy::IfAuthored";
    case pxr::UsdUtilsRegisteredVariantSet::SelectionExportPolicy::Always: return "pxr::UsdUtilsRegisteredVariantSet::SelectionExportPolicy::Always";
    default: return "pxr::UsdUtilsRegisteredVariantSet::SelectionExportPolicy(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::UsdUtilsStitchValueStatus& x) {
    switch (x) {
    case pxr::UsdUtilsStitchValueStatus::NoStitchedValue: return "pxr::UsdUtilsStitchValueStatus::NoStitchedValue";
    case pxr::UsdUtilsStitchValueStatus::UseDefaultValue: return "pxr::UsdUtilsStitchValueStatus::UseDefaultValue";
    case pxr::UsdUtilsStitchValueStatus::UseSuppliedValue: return "pxr::UsdUtilsStitchValueStatus::UseSuppliedValue";
    default: return "pxr::UsdUtilsStitchValueStatus(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::UsdUtilsTimeCodeRange& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::UsdPhysicsObjectType& x) {
    switch (x) {
    case pxr::UsdPhysicsObjectType::Undefined: return "pxr::UsdPhysicsObjectType::Undefined";
    case pxr::UsdPhysicsObjectType::Scene: return "pxr::UsdPhysicsObjectType::Scene";
    case pxr::UsdPhysicsObjectType::RigidBody: return "pxr::UsdPhysicsObjectType::RigidBody";
    case pxr::UsdPhysicsObjectType::SphereShape: return "pxr::UsdPhysicsObjectType::SphereShape";
    case pxr::UsdPhysicsObjectType::CubeShape: return "pxr::UsdPhysicsObjectType::CubeShape";
    case pxr::UsdPhysicsObjectType::CapsuleShape: return "pxr::UsdPhysicsObjectType::CapsuleShape";
    case pxr::UsdPhysicsObjectType::Capsule1Shape: return "pxr::UsdPhysicsObjectType::Capsule1Shape";
    case pxr::UsdPhysicsObjectType::CylinderShape: return "pxr::UsdPhysicsObjectType::CylinderShape";
    case pxr::UsdPhysicsObjectType::Cylinder1Shape: return "pxr::UsdPhysicsObjectType::Cylinder1Shape";
    case pxr::UsdPhysicsObjectType::ConeShape: return "pxr::UsdPhysicsObjectType::ConeShape";
    case pxr::UsdPhysicsObjectType::MeshShape: return "pxr::UsdPhysicsObjectType::MeshShape";
    case pxr::UsdPhysicsObjectType::PlaneShape: return "pxr::UsdPhysicsObjectType::PlaneShape";
    case pxr::UsdPhysicsObjectType::CustomShape: return "pxr::UsdPhysicsObjectType::CustomShape";
    case pxr::UsdPhysicsObjectType::SpherePointsShape: return "pxr::UsdPhysicsObjectType::SpherePointsShape";
    case pxr::UsdPhysicsObjectType::FixedJoint: return "pxr::UsdPhysicsObjectType::FixedJoint";
    case pxr::UsdPhysicsObjectType::RevoluteJoint: return "pxr::UsdPhysicsObjectType::RevoluteJoint";
    case pxr::UsdPhysicsObjectType::PrismaticJoint: return "pxr::UsdPhysicsObjectType::PrismaticJoint";
    case pxr::UsdPhysicsObjectType::SphericalJoint: return "pxr::UsdPhysicsObjectType::SphericalJoint";
    case pxr::UsdPhysicsObjectType::DistanceJoint: return "pxr::UsdPhysicsObjectType::DistanceJoint";
    case pxr::UsdPhysicsObjectType::D6Joint: return "pxr::UsdPhysicsObjectType::D6Joint";
    case pxr::UsdPhysicsObjectType::CustomJoint: return "pxr::UsdPhysicsObjectType::CustomJoint";
    case pxr::UsdPhysicsObjectType::RigidBodyMaterial: return "pxr::UsdPhysicsObjectType::RigidBodyMaterial";
    case pxr::UsdPhysicsObjectType::Articulation: return "pxr::UsdPhysicsObjectType::Articulation";
    case pxr::UsdPhysicsObjectType::CollisionGroup: return "pxr::UsdPhysicsObjectType::CollisionGroup";
    case pxr::UsdPhysicsObjectType::Last: return "pxr::UsdPhysicsObjectType::Last";
    default: return "pxr::UsdPhysicsObjectType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::UsdPhysicsAxis& x) {
    switch (x) {
    case pxr::UsdPhysicsAxis::X: return "pxr::UsdPhysicsAxis::X";
    case pxr::UsdPhysicsAxis::Y: return "pxr::UsdPhysicsAxis::Y";
    case pxr::UsdPhysicsAxis::Z: return "pxr::UsdPhysicsAxis::Z";
    default: return "pxr::UsdPhysicsAxis(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::UsdPhysicsJointDOF& x) {
    switch (x) {
    case pxr::UsdPhysicsJointDOF::Distance: return "pxr::UsdPhysicsJointDOF::Distance";
    case pxr::UsdPhysicsJointDOF::TransX: return "pxr::UsdPhysicsJointDOF::TransX";
    case pxr::UsdPhysicsJointDOF::TransY: return "pxr::UsdPhysicsJointDOF::TransY";
    case pxr::UsdPhysicsJointDOF::TransZ: return "pxr::UsdPhysicsJointDOF::TransZ";
    case pxr::UsdPhysicsJointDOF::RotX: return "pxr::UsdPhysicsJointDOF::RotX";
    case pxr::UsdPhysicsJointDOF::RotY: return "pxr::UsdPhysicsJointDOF::RotY";
    case pxr::UsdPhysicsJointDOF::RotZ: return "pxr::UsdPhysicsJointDOF::RotZ";
    default: return "pxr::UsdPhysicsJointDOF(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::VdfInputSpec::Access& x) {
    switch (x) {
    case pxr::VdfInputSpec::READ: return "pxr::VdfInputSpec::READ";
    case pxr::VdfInputSpec::READWRITE: return "pxr::VdfInputSpec::READWRITE";
    default: return "pxr::VdfInputSpec::Access(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::VdfMask& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VdfVector::ConstructBoxedCopyTag& x) {
    switch (x) {
    case pxr::VdfVector::ConstructBoxedCopy: return "pxr::VdfVector::ConstructBoxedCopy";
    default: return "pxr::VdfVector::ConstructBoxedCopyTag(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::VdfVector::DebugPrintable& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VdfIndexedWeights& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VdfExecutionStats::EventType& x) {
    switch (x) {
    case pxr::VdfExecutionStats::NodeEvaluateEvent: return "pxr::VdfExecutionStats::NodeEvaluateEvent";
    case pxr::VdfExecutionStats::NodePrepareEvent: return "pxr::VdfExecutionStats::NodePrepareEvent";
    case pxr::VdfExecutionStats::NodeRequiredInputsEvent: return "pxr::VdfExecutionStats::NodeRequiredInputsEvent";
    case pxr::VdfExecutionStats::NodeInputsTaskEvent: return "pxr::VdfExecutionStats::NodeInputsTaskEvent";
    case pxr::VdfExecutionStats::NodeDidComputeEvent: return "pxr::VdfExecutionStats::NodeDidComputeEvent";
    case pxr::VdfExecutionStats::ElementsCopiedEvent: return "pxr::VdfExecutionStats::ElementsCopiedEvent";
    case pxr::VdfExecutionStats::ElementsProcessedEvent: return "pxr::VdfExecutionStats::ElementsProcessedEvent";
    case pxr::VdfExecutionStats::RequestedOutputInSpeculationsEvent: return "pxr::VdfExecutionStats::RequestedOutputInSpeculationsEvent";
    case pxr::VdfExecutionStats::MaxEvent: return "pxr::VdfExecutionStats::MaxEvent";
    default: return "pxr::VdfExecutionStats::EventType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::VdfMaskedIteratorMode& x) {
    switch (x) {
    case pxr::VdfMaskedIteratorMode::VisitUnset: return "pxr::VdfMaskedIteratorMode::VisitUnset";
    case pxr::VdfMaskedIteratorMode::VisitSet: return "pxr::VdfMaskedIteratorMode::VisitSet";
    default: return "pxr::VdfMaskedIteratorMode(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::VdfDataManagerDeallocationMode& x) {
    switch (x) {
    case pxr::VdfDataManagerDeallocationMode::Background: return "pxr::VdfDataManagerDeallocationMode::Background";
    case pxr::VdfDataManagerDeallocationMode::Immediate: return "pxr::VdfDataManagerDeallocationMode::Immediate";
    default: return "pxr::VdfDataManagerDeallocationMode(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::VdfGrapherOptions::DisplayStyle& x) {
    switch (x) {
    case pxr::VdfGrapherOptions::DisplayStyleFull: return "pxr::VdfGrapherOptions::DisplayStyleFull";
    case pxr::VdfGrapherOptions::DisplayStyleNoLabels: return "pxr::VdfGrapherOptions::DisplayStyleNoLabels";
    case pxr::VdfGrapherOptions::DisplayStyleSummary: return "pxr::VdfGrapherOptions::DisplayStyleSummary";
    default: return "pxr::VdfGrapherOptions::DisplayStyle(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::VdfObjectPtr& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::VdfObjectPtr::Type& x) {
    switch (x) {
    case pxr::VdfObjectPtr::Undefined: return "pxr::VdfObjectPtr::Undefined";
    case pxr::VdfObjectPtr::Node: return "pxr::VdfObjectPtr::Node";
    case pxr::VdfObjectPtr::Connection: return "pxr::VdfObjectPtr::Connection";
    case pxr::VdfObjectPtr::Input: return "pxr::VdfObjectPtr::Input";
    case pxr::VdfObjectPtr::Output: return "pxr::VdfObjectPtr::Output";
    default: return "pxr::VdfObjectPtr::Type(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::VdfIndexedWeightsOperand::SetOperation& x) {
    switch (x) {
    case pxr::VdfIndexedWeightsOperand::Union: return "pxr::VdfIndexedWeightsOperand::Union";
    case pxr::VdfIndexedWeightsOperand::Intersection: return "pxr::VdfIndexedWeightsOperand::Intersection";
    default: return "pxr::VdfIndexedWeightsOperand::SetOperation(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::VdfSparseInputTraverser::CallbackMode& x) {
    switch (x) {
    case pxr::VdfSparseInputTraverser::CallbackModeAllNodes: return "pxr::VdfSparseInputTraverser::CallbackModeAllNodes";
    case pxr::VdfSparseInputTraverser::CallbackModeTerminalNodes: return "pxr::VdfSparseInputTraverser::CallbackModeTerminalNodes";
    default: return "pxr::VdfSparseInputTraverser::CallbackMode(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::VdfSparseVectorizedInputTraverser::CallbackMode& x) {
    switch (x) {
    case pxr::VdfSparseVectorizedInputTraverser::CallbackModeAllNodes: return "pxr::VdfSparseVectorizedInputTraverser::CallbackModeAllNodes";
    case pxr::VdfSparseVectorizedInputTraverser::CallbackModeTerminalNodes: return "pxr::VdfSparseVectorizedInputTraverser::CallbackModeTerminalNodes";
    default: return "pxr::VdfSparseVectorizedInputTraverser::CallbackMode(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::EfTime& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::EfTimeInterval& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::ExecProviderResolution::DynamicTraversal& x) {
    switch (x) {
    case pxr::ExecProviderResolution::DynamicTraversal::Local: return "pxr::ExecProviderResolution::DynamicTraversal::Local";
    case pxr::ExecProviderResolution::DynamicTraversal::RelationshipTargetedObjects: return "pxr::ExecProviderResolution::DynamicTraversal::RelationshipTargetedObjects";
    case pxr::ExecProviderResolution::DynamicTraversal::NamespaceAncestor: return "pxr::ExecProviderResolution::DynamicTraversal::NamespaceAncestor";
    default: return "pxr::ExecProviderResolution::DynamicTraversal(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
#if SwiftUsd_PXR_ENABLE_IMAGING_SUPPORT
std::string __Overlay::to_string(const pxr::GarchGLDebugWindow::Buttons& x) {
    switch (x) {
    case pxr::GarchGLDebugWindow::MyButton1: return "pxr::GarchGLDebugWindow::MyButton1";
    case pxr::GarchGLDebugWindow::MyButton2: return "pxr::GarchGLDebugWindow::MyButton2";
    case pxr::GarchGLDebugWindow::MyButton3: return "pxr::GarchGLDebugWindow::MyButton3";
    default: return "pxr::GarchGLDebugWindow::Buttons(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::GarchGLDebugWindow::ModifierKeys& x) {
    switch (x) {
    case pxr::GarchGLDebugWindow::NoModifiers: return "pxr::GarchGLDebugWindow::NoModifiers";
    case pxr::GarchGLDebugWindow::Shift: return "pxr::GarchGLDebugWindow::Shift";
    case pxr::GarchGLDebugWindow::Alt: return "pxr::GarchGLDebugWindow::Alt";
    case pxr::GarchGLDebugWindow::Ctrl: return "pxr::GarchGLDebugWindow::Ctrl";
    default: return "pxr::GarchGLDebugWindow::ModifierKeys(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
#endif // #if SwiftUsd_PXR_ENABLE_IMAGING_SUPPORT
#if SwiftUsd_PXR_ENABLE_IMAGING_SUPPORT && defined(ARCH_OS_DARWIN)
std::string __Overlay::to_string(const pxr::GarchNSGLContextState::NullState& x) {
    switch (x) {
    case pxr::GarchNSGLContextState::NullState::nullstate: return "pxr::GarchNSGLContextState::NullState::nullstate";
    default: return "pxr::GarchNSGLContextState::NullState(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
#endif // #if SwiftUsd_PXR_ENABLE_IMAGING_SUPPORT && defined(ARCH_OS_DARWIN)
#if SwiftUsd_PXR_ENABLE_IMAGING_SUPPORT
std::string __Overlay::to_string(const pxr::HioFormat& x) {
    switch (x) {
    case pxr::HioFormatInvalid: return "pxr::HioFormatInvalid";
    case pxr::HioFormatUNorm8: return "pxr::HioFormatUNorm8";
    case pxr::HioFormatUNorm8Vec2: return "pxr::HioFormatUNorm8Vec2";
    case pxr::HioFormatUNorm8Vec3: return "pxr::HioFormatUNorm8Vec3";
    case pxr::HioFormatUNorm8Vec4: return "pxr::HioFormatUNorm8Vec4";
    case pxr::HioFormatSNorm8: return "pxr::HioFormatSNorm8";
    case pxr::HioFormatSNorm8Vec2: return "pxr::HioFormatSNorm8Vec2";
    case pxr::HioFormatSNorm8Vec3: return "pxr::HioFormatSNorm8Vec3";
    case pxr::HioFormatSNorm8Vec4: return "pxr::HioFormatSNorm8Vec4";
    case pxr::HioFormatFloat16: return "pxr::HioFormatFloat16";
    case pxr::HioFormatFloat16Vec2: return "pxr::HioFormatFloat16Vec2";
    case pxr::HioFormatFloat16Vec3: return "pxr::HioFormatFloat16Vec3";
    case pxr::HioFormatFloat16Vec4: return "pxr::HioFormatFloat16Vec4";
    case pxr::HioFormatFloat32: return "pxr::HioFormatFloat32";
    case pxr::HioFormatFloat32Vec2: return "pxr::HioFormatFloat32Vec2";
    case pxr::HioFormatFloat32Vec3: return "pxr::HioFormatFloat32Vec3";
    case pxr::HioFormatFloat32Vec4: return "pxr::HioFormatFloat32Vec4";
    case pxr::HioFormatDouble64: return "pxr::HioFormatDouble64";
    case pxr::HioFormatDouble64Vec2: return "pxr::HioFormatDouble64Vec2";
    case pxr::HioFormatDouble64Vec3: return "pxr::HioFormatDouble64Vec3";
    case pxr::HioFormatDouble64Vec4: return "pxr::HioFormatDouble64Vec4";
    case pxr::HioFormatUInt16: return "pxr::HioFormatUInt16";
    case pxr::HioFormatUInt16Vec2: return "pxr::HioFormatUInt16Vec2";
    case pxr::HioFormatUInt16Vec3: return "pxr::HioFormatUInt16Vec3";
    case pxr::HioFormatUInt16Vec4: return "pxr::HioFormatUInt16Vec4";
    case pxr::HioFormatInt16: return "pxr::HioFormatInt16";
    case pxr::HioFormatInt16Vec2: return "pxr::HioFormatInt16Vec2";
    case pxr::HioFormatInt16Vec3: return "pxr::HioFormatInt16Vec3";
    case pxr::HioFormatInt16Vec4: return "pxr::HioFormatInt16Vec4";
    case pxr::HioFormatUInt32: return "pxr::HioFormatUInt32";
    case pxr::HioFormatUInt32Vec2: return "pxr::HioFormatUInt32Vec2";
    case pxr::HioFormatUInt32Vec3: return "pxr::HioFormatUInt32Vec3";
    case pxr::HioFormatUInt32Vec4: return "pxr::HioFormatUInt32Vec4";
    case pxr::HioFormatInt32: return "pxr::HioFormatInt32";
    case pxr::HioFormatInt32Vec2: return "pxr::HioFormatInt32Vec2";
    case pxr::HioFormatInt32Vec3: return "pxr::HioFormatInt32Vec3";
    case pxr::HioFormatInt32Vec4: return "pxr::HioFormatInt32Vec4";
    case pxr::HioFormatUNorm8srgb: return "pxr::HioFormatUNorm8srgb";
    case pxr::HioFormatUNorm8Vec2srgb: return "pxr::HioFormatUNorm8Vec2srgb";
    case pxr::HioFormatUNorm8Vec3srgb: return "pxr::HioFormatUNorm8Vec3srgb";
    case pxr::HioFormatUNorm8Vec4srgb: return "pxr::HioFormatUNorm8Vec4srgb";
    case pxr::HioFormatBC6FloatVec3: return "pxr::HioFormatBC6FloatVec3";
    case pxr::HioFormatBC6UFloatVec3: return "pxr::HioFormatBC6UFloatVec3";
    case pxr::HioFormatBC7UNorm8Vec4: return "pxr::HioFormatBC7UNorm8Vec4";
    case pxr::HioFormatBC7UNorm8Vec4srgb: return "pxr::HioFormatBC7UNorm8Vec4srgb";
    case pxr::HioFormatBC1UNorm8Vec4: return "pxr::HioFormatBC1UNorm8Vec4";
    case pxr::HioFormatBC3UNorm8Vec4: return "pxr::HioFormatBC3UNorm8Vec4";
    case pxr::HioFormatCount: return "pxr::HioFormatCount";
    default: return "pxr::HioFormat(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HioAddressDimension& x) {
    switch (x) {
    case pxr::HioAddressDimensionU: return "pxr::HioAddressDimensionU";
    case pxr::HioAddressDimensionV: return "pxr::HioAddressDimensionV";
    case pxr::HioAddressDimensionW: return "pxr::HioAddressDimensionW";
    default: return "pxr::HioAddressDimension(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HioAddressMode& x) {
    switch (x) {
    case pxr::HioAddressModeClampToEdge: return "pxr::HioAddressModeClampToEdge";
    case pxr::HioAddressModeMirrorClampToEdge: return "pxr::HioAddressModeMirrorClampToEdge";
    case pxr::HioAddressModeRepeat: return "pxr::HioAddressModeRepeat";
    case pxr::HioAddressModeMirrorRepeat: return "pxr::HioAddressModeMirrorRepeat";
    case pxr::HioAddressModeClampToBorderColor: return "pxr::HioAddressModeClampToBorderColor";
    default: return "pxr::HioAddressMode(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HioType& x) {
    switch (x) {
    case pxr::HioTypeUnsignedByte: return "pxr::HioTypeUnsignedByte";
    case pxr::HioTypeUnsignedByteSRGB: return "pxr::HioTypeUnsignedByteSRGB";
    case pxr::HioTypeSignedByte: return "pxr::HioTypeSignedByte";
    case pxr::HioTypeUnsignedShort: return "pxr::HioTypeUnsignedShort";
    case pxr::HioTypeSignedShort: return "pxr::HioTypeSignedShort";
    case pxr::HioTypeUnsignedInt: return "pxr::HioTypeUnsignedInt";
    case pxr::HioTypeInt: return "pxr::HioTypeInt";
    case pxr::HioTypeHalfFloat: return "pxr::HioTypeHalfFloat";
    case pxr::HioTypeFloat: return "pxr::HioTypeFloat";
    case pxr::HioTypeDouble: return "pxr::HioTypeDouble";
    case pxr::HioTypeCount: return "pxr::HioTypeCount";
    default: return "pxr::HioType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HioGlslfxConfig::Role& x) {
    switch (x) {
    case pxr::HioGlslfxConfig::RoleNone: return "pxr::HioGlslfxConfig::RoleNone";
    case pxr::HioGlslfxConfig::RoleColor: return "pxr::HioGlslfxConfig::RoleColor";
    default: return "pxr::HioGlslfxConfig::Role(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HioGlslfxResourceLayout::InOut& x) {
    switch (x) {
    case pxr::HioGlslfxResourceLayout::InOut::NONE: return "pxr::HioGlslfxResourceLayout::InOut::NONE";
    case pxr::HioGlslfxResourceLayout::InOut::STAGE_IN: return "pxr::HioGlslfxResourceLayout::InOut::STAGE_IN";
    case pxr::HioGlslfxResourceLayout::InOut::STAGE_OUT: return "pxr::HioGlslfxResourceLayout::InOut::STAGE_OUT";
    default: return "pxr::HioGlslfxResourceLayout::InOut(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HioGlslfxResourceLayout::Kind& x) {
    switch (x) {
    case pxr::HioGlslfxResourceLayout::Kind::NONE: return "pxr::HioGlslfxResourceLayout::Kind::NONE";
    case pxr::HioGlslfxResourceLayout::Kind::VALUE: return "pxr::HioGlslfxResourceLayout::Kind::VALUE";
    case pxr::HioGlslfxResourceLayout::Kind::BLOCK: return "pxr::HioGlslfxResourceLayout::Kind::BLOCK";
    case pxr::HioGlslfxResourceLayout::Kind::QUALIFIER: return "pxr::HioGlslfxResourceLayout::Kind::QUALIFIER";
    case pxr::HioGlslfxResourceLayout::Kind::UNIFORM_VALUE: return "pxr::HioGlslfxResourceLayout::Kind::UNIFORM_VALUE";
    case pxr::HioGlslfxResourceLayout::Kind::UNIFORM_BLOCK: return "pxr::HioGlslfxResourceLayout::Kind::UNIFORM_BLOCK";
    case pxr::HioGlslfxResourceLayout::Kind::UNIFORM_BLOCK_CONSTANT_PARAMS: return "pxr::HioGlslfxResourceLayout::Kind::UNIFORM_BLOCK_CONSTANT_PARAMS";
    case pxr::HioGlslfxResourceLayout::Kind::BUFFER_READ_ONLY: return "pxr::HioGlslfxResourceLayout::Kind::BUFFER_READ_ONLY";
    case pxr::HioGlslfxResourceLayout::Kind::BUFFER_READ_WRITE: return "pxr::HioGlslfxResourceLayout::Kind::BUFFER_READ_WRITE";
    default: return "pxr::HioGlslfxResourceLayout::Kind(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HioGlslfxResourceLayout::TextureType& x) {
    switch (x) {
    case pxr::HioGlslfxResourceLayout::TextureType::TEXTURE: return "pxr::HioGlslfxResourceLayout::TextureType::TEXTURE";
    case pxr::HioGlslfxResourceLayout::TextureType::SHADOW_TEXTURE: return "pxr::HioGlslfxResourceLayout::TextureType::SHADOW_TEXTURE";
    case pxr::HioGlslfxResourceLayout::TextureType::ARRAY_TEXTURE: return "pxr::HioGlslfxResourceLayout::TextureType::ARRAY_TEXTURE";
    default: return "pxr::HioGlslfxResourceLayout::TextureType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::CameraUtilConformWindowPolicy& x) {
    switch (x) {
    case pxr::CameraUtilMatchVertically: return "pxr::CameraUtilMatchVertically";
    case pxr::CameraUtilMatchHorizontally: return "pxr::CameraUtilMatchHorizontally";
    case pxr::CameraUtilFit: return "pxr::CameraUtilFit";
    case pxr::CameraUtilCrop: return "pxr::CameraUtilCrop";
    case pxr::CameraUtilDontConform: return "pxr::CameraUtilDontConform";
    default: return "pxr::CameraUtilConformWindowPolicy(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::PxOsdMeshTopology& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::PxOsdSubdivTags& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::PxOsdMeshTopologyValidation::Code& x) {
    switch (x) {
    case pxr::PxOsdMeshTopologyValidation::Code::InvalidScheme: return "pxr::PxOsdMeshTopologyValidation::Code::InvalidScheme";
    case pxr::PxOsdMeshTopologyValidation::Code::InvalidOrientation: return "pxr::PxOsdMeshTopologyValidation::Code::InvalidOrientation";
    case pxr::PxOsdMeshTopologyValidation::Code::InvalidTriangleSubdivision: return "pxr::PxOsdMeshTopologyValidation::Code::InvalidTriangleSubdivision";
    case pxr::PxOsdMeshTopologyValidation::Code::InvalidVertexInterpolationRule: return "pxr::PxOsdMeshTopologyValidation::Code::InvalidVertexInterpolationRule";
    case pxr::PxOsdMeshTopologyValidation::Code::InvalidFaceVaryingInterpolationRule: return "pxr::PxOsdMeshTopologyValidation::Code::InvalidFaceVaryingInterpolationRule";
    case pxr::PxOsdMeshTopologyValidation::Code::InvalidCreaseMethod: return "pxr::PxOsdMeshTopologyValidation::Code::InvalidCreaseMethod";
    case pxr::PxOsdMeshTopologyValidation::Code::InvalidCreaseLengthElement: return "pxr::PxOsdMeshTopologyValidation::Code::InvalidCreaseLengthElement";
    case pxr::PxOsdMeshTopologyValidation::Code::InvalidCreaseIndicesSize: return "pxr::PxOsdMeshTopologyValidation::Code::InvalidCreaseIndicesSize";
    case pxr::PxOsdMeshTopologyValidation::Code::InvalidCreaseIndicesElement: return "pxr::PxOsdMeshTopologyValidation::Code::InvalidCreaseIndicesElement";
    case pxr::PxOsdMeshTopologyValidation::Code::InvalidCreaseWeightsSize: return "pxr::PxOsdMeshTopologyValidation::Code::InvalidCreaseWeightsSize";
    case pxr::PxOsdMeshTopologyValidation::Code::NegativeCreaseWeights: return "pxr::PxOsdMeshTopologyValidation::Code::NegativeCreaseWeights";
    case pxr::PxOsdMeshTopologyValidation::Code::InvalidCornerIndicesElement: return "pxr::PxOsdMeshTopologyValidation::Code::InvalidCornerIndicesElement";
    case pxr::PxOsdMeshTopologyValidation::Code::NegativeCornerWeights: return "pxr::PxOsdMeshTopologyValidation::Code::NegativeCornerWeights";
    case pxr::PxOsdMeshTopologyValidation::Code::InvalidCornerWeightsSize: return "pxr::PxOsdMeshTopologyValidation::Code::InvalidCornerWeightsSize";
    case pxr::PxOsdMeshTopologyValidation::Code::InvalidHoleIndicesElement: return "pxr::PxOsdMeshTopologyValidation::Code::InvalidHoleIndicesElement";
    case pxr::PxOsdMeshTopologyValidation::Code::InvalidFaceVertexCountsElement: return "pxr::PxOsdMeshTopologyValidation::Code::InvalidFaceVertexCountsElement";
    case pxr::PxOsdMeshTopologyValidation::Code::InvalidFaceVertexIndicesElement: return "pxr::PxOsdMeshTopologyValidation::Code::InvalidFaceVertexIndicesElement";
    case pxr::PxOsdMeshTopologyValidation::Code::InvalidFaceVertexIndicesSize: return "pxr::PxOsdMeshTopologyValidation::Code::InvalidFaceVertexIndicesSize";
    default: return "pxr::PxOsdMeshTopologyValidation::Code(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::GlfSimpleLight& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::HgiAttachmentDesc& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::HgiDeviceCapabilitiesBits& x) {
    switch (x) {
    case pxr::HgiDeviceCapabilitiesBitsPresentation: return "pxr::HgiDeviceCapabilitiesBitsPresentation";
    case pxr::HgiDeviceCapabilitiesBitsBindlessBuffers: return "pxr::HgiDeviceCapabilitiesBitsBindlessBuffers";
    case pxr::HgiDeviceCapabilitiesBitsConcurrentDispatch: return "pxr::HgiDeviceCapabilitiesBitsConcurrentDispatch";
    case pxr::HgiDeviceCapabilitiesBitsUnifiedMemory: return "pxr::HgiDeviceCapabilitiesBitsUnifiedMemory";
    case pxr::HgiDeviceCapabilitiesBitsBuiltinBarycentrics: return "pxr::HgiDeviceCapabilitiesBitsBuiltinBarycentrics";
    case pxr::HgiDeviceCapabilitiesBitsShaderDrawParameters: return "pxr::HgiDeviceCapabilitiesBitsShaderDrawParameters";
    case pxr::HgiDeviceCapabilitiesBitsMultiDrawIndirect: return "pxr::HgiDeviceCapabilitiesBitsMultiDrawIndirect";
    case pxr::HgiDeviceCapabilitiesBitsBindlessTextures: return "pxr::HgiDeviceCapabilitiesBitsBindlessTextures";
    case pxr::HgiDeviceCapabilitiesBitsShaderDoublePrecision: return "pxr::HgiDeviceCapabilitiesBitsShaderDoublePrecision";
    case pxr::HgiDeviceCapabilitiesBitsDepthRangeMinusOnetoOne: return "pxr::HgiDeviceCapabilitiesBitsDepthRangeMinusOnetoOne";
    case pxr::HgiDeviceCapabilitiesBitsCppShaderPadding: return "pxr::HgiDeviceCapabilitiesBitsCppShaderPadding";
    case pxr::HgiDeviceCapabilitiesBitsConservativeRaster: return "pxr::HgiDeviceCapabilitiesBitsConservativeRaster";
    case pxr::HgiDeviceCapabilitiesBitsStencilReadback: return "pxr::HgiDeviceCapabilitiesBitsStencilReadback";
    case pxr::HgiDeviceCapabilitiesBitsCustomDepthRange: return "pxr::HgiDeviceCapabilitiesBitsCustomDepthRange";
    case pxr::HgiDeviceCapabilitiesBitsMetalTessellation: return "pxr::HgiDeviceCapabilitiesBitsMetalTessellation";
    case pxr::HgiDeviceCapabilitiesBitsBasePrimitiveOffset: return "pxr::HgiDeviceCapabilitiesBitsBasePrimitiveOffset";
    case pxr::HgiDeviceCapabilitiesBitsPrimitiveIdEmulation: return "pxr::HgiDeviceCapabilitiesBitsPrimitiveIdEmulation";
    case pxr::HgiDeviceCapabilitiesBitsIndirectCommandBuffers: return "pxr::HgiDeviceCapabilitiesBitsIndirectCommandBuffers";
    case pxr::HgiDeviceCapabilitiesBitsRoundPoints: return "pxr::HgiDeviceCapabilitiesBitsRoundPoints";
    case pxr::HgiDeviceCapabilitiesBitsSingleSlotResourceArrays: return "pxr::HgiDeviceCapabilitiesBitsSingleSlotResourceArrays";
    default: return "pxr::HgiDeviceCapabilitiesBits(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiTextureType& x) {
    switch (x) {
    case pxr::HgiTextureType1D: return "pxr::HgiTextureType1D";
    case pxr::HgiTextureType2D: return "pxr::HgiTextureType2D";
    case pxr::HgiTextureType3D: return "pxr::HgiTextureType3D";
    case pxr::HgiTextureType1DArray: return "pxr::HgiTextureType1DArray";
    case pxr::HgiTextureType2DArray: return "pxr::HgiTextureType2DArray";
    case pxr::HgiTextureTypeCount: return "pxr::HgiTextureTypeCount";
    default: return "pxr::HgiTextureType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiTextureUsageBits& x) {
    switch (x) {
    case pxr::HgiTextureUsageBitsColorTarget: return "pxr::HgiTextureUsageBitsColorTarget";
    case pxr::HgiTextureUsageBitsDepthTarget: return "pxr::HgiTextureUsageBitsDepthTarget";
    case pxr::HgiTextureUsageBitsStencilTarget: return "pxr::HgiTextureUsageBitsStencilTarget";
    case pxr::HgiTextureUsageBitsShaderRead: return "pxr::HgiTextureUsageBitsShaderRead";
    case pxr::HgiTextureUsageBitsShaderWrite: return "pxr::HgiTextureUsageBitsShaderWrite";
    case pxr::HgiTextureUsageCustomBitsBegin: return "pxr::HgiTextureUsageCustomBitsBegin";
    default: return "pxr::HgiTextureUsageBits(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiSamplerAddressMode& x) {
    switch (x) {
    case pxr::HgiSamplerAddressModeClampToEdge: return "pxr::HgiSamplerAddressModeClampToEdge";
    case pxr::HgiSamplerAddressModeMirrorClampToEdge: return "pxr::HgiSamplerAddressModeMirrorClampToEdge";
    case pxr::HgiSamplerAddressModeRepeat: return "pxr::HgiSamplerAddressModeRepeat";
    case pxr::HgiSamplerAddressModeMirrorRepeat: return "pxr::HgiSamplerAddressModeMirrorRepeat";
    case pxr::HgiSamplerAddressModeClampToBorderColor: return "pxr::HgiSamplerAddressModeClampToBorderColor";
    case pxr::HgiSamplerAddressModeCount: return "pxr::HgiSamplerAddressModeCount";
    default: return "pxr::HgiSamplerAddressMode(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiSamplerFilter& x) {
    switch (x) {
    case pxr::HgiSamplerFilterNearest: return "pxr::HgiSamplerFilterNearest";
    case pxr::HgiSamplerFilterLinear: return "pxr::HgiSamplerFilterLinear";
    case pxr::HgiSamplerFilterCount: return "pxr::HgiSamplerFilterCount";
    default: return "pxr::HgiSamplerFilter(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiMipFilter& x) {
    switch (x) {
    case pxr::HgiMipFilterNotMipmapped: return "pxr::HgiMipFilterNotMipmapped";
    case pxr::HgiMipFilterNearest: return "pxr::HgiMipFilterNearest";
    case pxr::HgiMipFilterLinear: return "pxr::HgiMipFilterLinear";
    case pxr::HgiMipFilterCount: return "pxr::HgiMipFilterCount";
    default: return "pxr::HgiMipFilter(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiBorderColor& x) {
    switch (x) {
    case pxr::HgiBorderColorTransparentBlack: return "pxr::HgiBorderColorTransparentBlack";
    case pxr::HgiBorderColorOpaqueBlack: return "pxr::HgiBorderColorOpaqueBlack";
    case pxr::HgiBorderColorOpaqueWhite: return "pxr::HgiBorderColorOpaqueWhite";
    case pxr::HgiBorderColorCount: return "pxr::HgiBorderColorCount";
    default: return "pxr::HgiBorderColor(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiSampleCount& x) {
    switch (x) {
    case pxr::HgiSampleCount1: return "pxr::HgiSampleCount1";
    case pxr::HgiSampleCount2: return "pxr::HgiSampleCount2";
    case pxr::HgiSampleCount4: return "pxr::HgiSampleCount4";
    case pxr::HgiSampleCount8: return "pxr::HgiSampleCount8";
    case pxr::HgiSampleCount16: return "pxr::HgiSampleCount16";
    case pxr::HgiSampleCountEnd: return "pxr::HgiSampleCountEnd";
    default: return "pxr::HgiSampleCount(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiAttachmentLoadOp& x) {
    switch (x) {
    case pxr::HgiAttachmentLoadOpDontCare: return "pxr::HgiAttachmentLoadOpDontCare";
    case pxr::HgiAttachmentLoadOpClear: return "pxr::HgiAttachmentLoadOpClear";
    case pxr::HgiAttachmentLoadOpLoad: return "pxr::HgiAttachmentLoadOpLoad";
    case pxr::HgiAttachmentLoadOpCount: return "pxr::HgiAttachmentLoadOpCount";
    default: return "pxr::HgiAttachmentLoadOp(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiAttachmentStoreOp& x) {
    switch (x) {
    case pxr::HgiAttachmentStoreOpDontCare: return "pxr::HgiAttachmentStoreOpDontCare";
    case pxr::HgiAttachmentStoreOpStore: return "pxr::HgiAttachmentStoreOpStore";
    case pxr::HgiAttachmentStoreOpCount: return "pxr::HgiAttachmentStoreOpCount";
    default: return "pxr::HgiAttachmentStoreOp(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiBufferUsageBits& x) {
    switch (x) {
    case pxr::HgiBufferUsageUniform: return "pxr::HgiBufferUsageUniform";
    case pxr::HgiBufferUsageIndex32: return "pxr::HgiBufferUsageIndex32";
    case pxr::HgiBufferUsageVertex: return "pxr::HgiBufferUsageVertex";
    case pxr::HgiBufferUsageStorage: return "pxr::HgiBufferUsageStorage";
    case pxr::HgiBufferUsageIndirect: return "pxr::HgiBufferUsageIndirect";
    case pxr::HgiBufferUsageCustomBitsBegin: return "pxr::HgiBufferUsageCustomBitsBegin";
    default: return "pxr::HgiBufferUsageBits(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiShaderStageBits& x) {
    switch (x) {
    case pxr::HgiShaderStageVertex: return "pxr::HgiShaderStageVertex";
    case pxr::HgiShaderStageFragment: return "pxr::HgiShaderStageFragment";
    case pxr::HgiShaderStageCompute: return "pxr::HgiShaderStageCompute";
    case pxr::HgiShaderStageTessellationControl: return "pxr::HgiShaderStageTessellationControl";
    case pxr::HgiShaderStageTessellationEval: return "pxr::HgiShaderStageTessellationEval";
    case pxr::HgiShaderStageGeometry: return "pxr::HgiShaderStageGeometry";
    case pxr::HgiShaderStagePostTessellationControl: return "pxr::HgiShaderStagePostTessellationControl";
    case pxr::HgiShaderStagePostTessellationVertex: return "pxr::HgiShaderStagePostTessellationVertex";
    case pxr::HgiShaderStageCustomBitsBegin: return "pxr::HgiShaderStageCustomBitsBegin";
    default: return "pxr::HgiShaderStageBits(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiBindResourceType& x) {
    switch (x) {
    case pxr::HgiBindResourceTypeSampler: return "pxr::HgiBindResourceTypeSampler";
    case pxr::HgiBindResourceTypeSampledImage: return "pxr::HgiBindResourceTypeSampledImage";
    case pxr::HgiBindResourceTypeCombinedSamplerImage: return "pxr::HgiBindResourceTypeCombinedSamplerImage";
    case pxr::HgiBindResourceTypeStorageImage: return "pxr::HgiBindResourceTypeStorageImage";
    case pxr::HgiBindResourceTypeUniformBuffer: return "pxr::HgiBindResourceTypeUniformBuffer";
    case pxr::HgiBindResourceTypeStorageBuffer: return "pxr::HgiBindResourceTypeStorageBuffer";
    case pxr::HgiBindResourceTypeTessFactors: return "pxr::HgiBindResourceTypeTessFactors";
    case pxr::HgiBindResourceTypeCount: return "pxr::HgiBindResourceTypeCount";
    default: return "pxr::HgiBindResourceType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiPolygonMode& x) {
    switch (x) {
    case pxr::HgiPolygonModeFill: return "pxr::HgiPolygonModeFill";
    case pxr::HgiPolygonModeLine: return "pxr::HgiPolygonModeLine";
    case pxr::HgiPolygonModePoint: return "pxr::HgiPolygonModePoint";
    case pxr::HgiPolygonModeCount: return "pxr::HgiPolygonModeCount";
    default: return "pxr::HgiPolygonMode(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiCullMode& x) {
    switch (x) {
    case pxr::HgiCullModeNone: return "pxr::HgiCullModeNone";
    case pxr::HgiCullModeFront: return "pxr::HgiCullModeFront";
    case pxr::HgiCullModeBack: return "pxr::HgiCullModeBack";
    case pxr::HgiCullModeFrontAndBack: return "pxr::HgiCullModeFrontAndBack";
    case pxr::HgiCullModeCount: return "pxr::HgiCullModeCount";
    default: return "pxr::HgiCullMode(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiWinding& x) {
    switch (x) {
    case pxr::HgiWindingClockwise: return "pxr::HgiWindingClockwise";
    case pxr::HgiWindingCounterClockwise: return "pxr::HgiWindingCounterClockwise";
    case pxr::HgiWindingCount: return "pxr::HgiWindingCount";
    default: return "pxr::HgiWinding(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiBlendOp& x) {
    switch (x) {
    case pxr::HgiBlendOpAdd: return "pxr::HgiBlendOpAdd";
    case pxr::HgiBlendOpSubtract: return "pxr::HgiBlendOpSubtract";
    case pxr::HgiBlendOpReverseSubtract: return "pxr::HgiBlendOpReverseSubtract";
    case pxr::HgiBlendOpMin: return "pxr::HgiBlendOpMin";
    case pxr::HgiBlendOpMax: return "pxr::HgiBlendOpMax";
    case pxr::HgiBlendOpCount: return "pxr::HgiBlendOpCount";
    default: return "pxr::HgiBlendOp(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiBlendFactor& x) {
    switch (x) {
    case pxr::HgiBlendFactorZero: return "pxr::HgiBlendFactorZero";
    case pxr::HgiBlendFactorOne: return "pxr::HgiBlendFactorOne";
    case pxr::HgiBlendFactorSrcColor: return "pxr::HgiBlendFactorSrcColor";
    case pxr::HgiBlendFactorOneMinusSrcColor: return "pxr::HgiBlendFactorOneMinusSrcColor";
    case pxr::HgiBlendFactorDstColor: return "pxr::HgiBlendFactorDstColor";
    case pxr::HgiBlendFactorOneMinusDstColor: return "pxr::HgiBlendFactorOneMinusDstColor";
    case pxr::HgiBlendFactorSrcAlpha: return "pxr::HgiBlendFactorSrcAlpha";
    case pxr::HgiBlendFactorOneMinusSrcAlpha: return "pxr::HgiBlendFactorOneMinusSrcAlpha";
    case pxr::HgiBlendFactorDstAlpha: return "pxr::HgiBlendFactorDstAlpha";
    case pxr::HgiBlendFactorOneMinusDstAlpha: return "pxr::HgiBlendFactorOneMinusDstAlpha";
    case pxr::HgiBlendFactorConstantColor: return "pxr::HgiBlendFactorConstantColor";
    case pxr::HgiBlendFactorOneMinusConstantColor: return "pxr::HgiBlendFactorOneMinusConstantColor";
    case pxr::HgiBlendFactorConstantAlpha: return "pxr::HgiBlendFactorConstantAlpha";
    case pxr::HgiBlendFactorOneMinusConstantAlpha: return "pxr::HgiBlendFactorOneMinusConstantAlpha";
    case pxr::HgiBlendFactorSrcAlphaSaturate: return "pxr::HgiBlendFactorSrcAlphaSaturate";
    case pxr::HgiBlendFactorSrc1Color: return "pxr::HgiBlendFactorSrc1Color";
    case pxr::HgiBlendFactorOneMinusSrc1Color: return "pxr::HgiBlendFactorOneMinusSrc1Color";
    case pxr::HgiBlendFactorSrc1Alpha: return "pxr::HgiBlendFactorSrc1Alpha";
    case pxr::HgiBlendFactorOneMinusSrc1Alpha: return "pxr::HgiBlendFactorOneMinusSrc1Alpha";
    case pxr::HgiBlendFactorCount: return "pxr::HgiBlendFactorCount";
    default: return "pxr::HgiBlendFactor(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiColorMaskBits& x) {
    switch (x) {
    case pxr::HgiColorMaskRed: return "pxr::HgiColorMaskRed";
    case pxr::HgiColorMaskGreen: return "pxr::HgiColorMaskGreen";
    case pxr::HgiColorMaskBlue: return "pxr::HgiColorMaskBlue";
    case pxr::HgiColorMaskAlpha: return "pxr::HgiColorMaskAlpha";
    default: return "pxr::HgiColorMaskBits(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiCompareFunction& x) {
    switch (x) {
    case pxr::HgiCompareFunctionNever: return "pxr::HgiCompareFunctionNever";
    case pxr::HgiCompareFunctionLess: return "pxr::HgiCompareFunctionLess";
    case pxr::HgiCompareFunctionEqual: return "pxr::HgiCompareFunctionEqual";
    case pxr::HgiCompareFunctionLEqual: return "pxr::HgiCompareFunctionLEqual";
    case pxr::HgiCompareFunctionGreater: return "pxr::HgiCompareFunctionGreater";
    case pxr::HgiCompareFunctionNotEqual: return "pxr::HgiCompareFunctionNotEqual";
    case pxr::HgiCompareFunctionGEqual: return "pxr::HgiCompareFunctionGEqual";
    case pxr::HgiCompareFunctionAlways: return "pxr::HgiCompareFunctionAlways";
    case pxr::HgiCompareFunctionCount: return "pxr::HgiCompareFunctionCount";
    default: return "pxr::HgiCompareFunction(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiStencilOp& x) {
    switch (x) {
    case pxr::HgiStencilOpKeep: return "pxr::HgiStencilOpKeep";
    case pxr::HgiStencilOpZero: return "pxr::HgiStencilOpZero";
    case pxr::HgiStencilOpReplace: return "pxr::HgiStencilOpReplace";
    case pxr::HgiStencilOpIncrementClamp: return "pxr::HgiStencilOpIncrementClamp";
    case pxr::HgiStencilOpDecrementClamp: return "pxr::HgiStencilOpDecrementClamp";
    case pxr::HgiStencilOpInvert: return "pxr::HgiStencilOpInvert";
    case pxr::HgiStencilOpIncrementWrap: return "pxr::HgiStencilOpIncrementWrap";
    case pxr::HgiStencilOpDecrementWrap: return "pxr::HgiStencilOpDecrementWrap";
    case pxr::HgiStencilOpCount: return "pxr::HgiStencilOpCount";
    default: return "pxr::HgiStencilOp(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiComponentSwizzle& x) {
    switch (x) {
    case pxr::HgiComponentSwizzleZero: return "pxr::HgiComponentSwizzleZero";
    case pxr::HgiComponentSwizzleOne: return "pxr::HgiComponentSwizzleOne";
    case pxr::HgiComponentSwizzleR: return "pxr::HgiComponentSwizzleR";
    case pxr::HgiComponentSwizzleG: return "pxr::HgiComponentSwizzleG";
    case pxr::HgiComponentSwizzleB: return "pxr::HgiComponentSwizzleB";
    case pxr::HgiComponentSwizzleA: return "pxr::HgiComponentSwizzleA";
    case pxr::HgiComponentSwizzleCount: return "pxr::HgiComponentSwizzleCount";
    default: return "pxr::HgiComponentSwizzle(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiPrimitiveType& x) {
    switch (x) {
    case pxr::HgiPrimitiveTypePointList: return "pxr::HgiPrimitiveTypePointList";
    case pxr::HgiPrimitiveTypeLineList: return "pxr::HgiPrimitiveTypeLineList";
    case pxr::HgiPrimitiveTypeLineStrip: return "pxr::HgiPrimitiveTypeLineStrip";
    case pxr::HgiPrimitiveTypeTriangleList: return "pxr::HgiPrimitiveTypeTriangleList";
    case pxr::HgiPrimitiveTypePatchList: return "pxr::HgiPrimitiveTypePatchList";
    case pxr::HgiPrimitiveTypeLineListWithAdjacency: return "pxr::HgiPrimitiveTypeLineListWithAdjacency";
    case pxr::HgiPrimitiveTypeCount: return "pxr::HgiPrimitiveTypeCount";
    default: return "pxr::HgiPrimitiveType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiVertexBufferStepFunction& x) {
    switch (x) {
    case pxr::HgiVertexBufferStepFunctionConstant: return "pxr::HgiVertexBufferStepFunctionConstant";
    case pxr::HgiVertexBufferStepFunctionPerVertex: return "pxr::HgiVertexBufferStepFunctionPerVertex";
    case pxr::HgiVertexBufferStepFunctionPerInstance: return "pxr::HgiVertexBufferStepFunctionPerInstance";
    case pxr::HgiVertexBufferStepFunctionPerPatch: return "pxr::HgiVertexBufferStepFunctionPerPatch";
    case pxr::HgiVertexBufferStepFunctionPerPatchControlPoint: return "pxr::HgiVertexBufferStepFunctionPerPatchControlPoint";
    case pxr::HgiVertexBufferStepFunctionPerDrawCommand: return "pxr::HgiVertexBufferStepFunctionPerDrawCommand";
    case pxr::HgiVertexBufferStepFunctionCount: return "pxr::HgiVertexBufferStepFunctionCount";
    default: return "pxr::HgiVertexBufferStepFunction(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiSubmitWaitType& x) {
    switch (x) {
    case pxr::HgiSubmitWaitTypeNoWait: return "pxr::HgiSubmitWaitTypeNoWait";
    case pxr::HgiSubmitWaitTypeWaitUntilCompleted: return "pxr::HgiSubmitWaitTypeWaitUntilCompleted";
    default: return "pxr::HgiSubmitWaitType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiMemoryBarrierBits& x) {
    switch (x) {
    case pxr::HgiMemoryBarrierNone: return "pxr::HgiMemoryBarrierNone";
    case pxr::HgiMemoryBarrierAll: return "pxr::HgiMemoryBarrierAll";
    default: return "pxr::HgiMemoryBarrierBits(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiBindingType& x) {
    switch (x) {
    case pxr::HgiBindingTypeValue: return "pxr::HgiBindingTypeValue";
    case pxr::HgiBindingTypeUniformValue: return "pxr::HgiBindingTypeUniformValue";
    case pxr::HgiBindingTypeArray: return "pxr::HgiBindingTypeArray";
    case pxr::HgiBindingTypeUniformArray: return "pxr::HgiBindingTypeUniformArray";
    case pxr::HgiBindingTypePointer: return "pxr::HgiBindingTypePointer";
    default: return "pxr::HgiBindingType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiInterpolationType& x) {
    switch (x) {
    case pxr::HgiInterpolationDefault: return "pxr::HgiInterpolationDefault";
    case pxr::HgiInterpolationFlat: return "pxr::HgiInterpolationFlat";
    case pxr::HgiInterpolationNoPerspective: return "pxr::HgiInterpolationNoPerspective";
    default: return "pxr::HgiInterpolationType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiSamplingType& x) {
    switch (x) {
    case pxr::HgiSamplingDefault: return "pxr::HgiSamplingDefault";
    case pxr::HgiSamplingCentroid: return "pxr::HgiSamplingCentroid";
    case pxr::HgiSamplingSample: return "pxr::HgiSamplingSample";
    default: return "pxr::HgiSamplingType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiStorageType& x) {
    switch (x) {
    case pxr::HgiStorageDefault: return "pxr::HgiStorageDefault";
    case pxr::HgiStoragePatch: return "pxr::HgiStoragePatch";
    default: return "pxr::HgiStorageType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiShaderTextureType& x) {
    switch (x) {
    case pxr::HgiShaderTextureTypeTexture: return "pxr::HgiShaderTextureTypeTexture";
    case pxr::HgiShaderTextureTypeShadowTexture: return "pxr::HgiShaderTextureTypeShadowTexture";
    case pxr::HgiShaderTextureTypeArrayTexture: return "pxr::HgiShaderTextureTypeArrayTexture";
    default: return "pxr::HgiShaderTextureType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiComputeDispatch& x) {
    switch (x) {
    case pxr::HgiComputeDispatchSerial: return "pxr::HgiComputeDispatchSerial";
    case pxr::HgiComputeDispatchConcurrent: return "pxr::HgiComputeDispatchConcurrent";
    default: return "pxr::HgiComputeDispatch(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiFormat& x) {
    switch (x) {
    case pxr::HgiFormatInvalid: return "pxr::HgiFormatInvalid";
    case pxr::HgiFormatUNorm8: return "pxr::HgiFormatUNorm8";
    case pxr::HgiFormatUNorm8Vec2: return "pxr::HgiFormatUNorm8Vec2";
    case pxr::HgiFormatUNorm8Vec4: return "pxr::HgiFormatUNorm8Vec4";
    case pxr::HgiFormatSNorm8: return "pxr::HgiFormatSNorm8";
    case pxr::HgiFormatSNorm8Vec2: return "pxr::HgiFormatSNorm8Vec2";
    case pxr::HgiFormatSNorm8Vec4: return "pxr::HgiFormatSNorm8Vec4";
    case pxr::HgiFormatFloat16: return "pxr::HgiFormatFloat16";
    case pxr::HgiFormatFloat16Vec2: return "pxr::HgiFormatFloat16Vec2";
    case pxr::HgiFormatFloat16Vec3: return "pxr::HgiFormatFloat16Vec3";
    case pxr::HgiFormatFloat16Vec4: return "pxr::HgiFormatFloat16Vec4";
    case pxr::HgiFormatFloat32: return "pxr::HgiFormatFloat32";
    case pxr::HgiFormatFloat32Vec2: return "pxr::HgiFormatFloat32Vec2";
    case pxr::HgiFormatFloat32Vec3: return "pxr::HgiFormatFloat32Vec3";
    case pxr::HgiFormatFloat32Vec4: return "pxr::HgiFormatFloat32Vec4";
    case pxr::HgiFormatInt16: return "pxr::HgiFormatInt16";
    case pxr::HgiFormatInt16Vec2: return "pxr::HgiFormatInt16Vec2";
    case pxr::HgiFormatInt16Vec3: return "pxr::HgiFormatInt16Vec3";
    case pxr::HgiFormatInt16Vec4: return "pxr::HgiFormatInt16Vec4";
    case pxr::HgiFormatUInt16: return "pxr::HgiFormatUInt16";
    case pxr::HgiFormatUInt16Vec2: return "pxr::HgiFormatUInt16Vec2";
    case pxr::HgiFormatUInt16Vec3: return "pxr::HgiFormatUInt16Vec3";
    case pxr::HgiFormatUInt16Vec4: return "pxr::HgiFormatUInt16Vec4";
    case pxr::HgiFormatInt32: return "pxr::HgiFormatInt32";
    case pxr::HgiFormatInt32Vec2: return "pxr::HgiFormatInt32Vec2";
    case pxr::HgiFormatInt32Vec3: return "pxr::HgiFormatInt32Vec3";
    case pxr::HgiFormatInt32Vec4: return "pxr::HgiFormatInt32Vec4";
    case pxr::HgiFormatUNorm8Vec4srgb: return "pxr::HgiFormatUNorm8Vec4srgb";
    case pxr::HgiFormatBC6FloatVec3: return "pxr::HgiFormatBC6FloatVec3";
    case pxr::HgiFormatBC6UFloatVec3: return "pxr::HgiFormatBC6UFloatVec3";
    case pxr::HgiFormatBC7UNorm8Vec4: return "pxr::HgiFormatBC7UNorm8Vec4";
    case pxr::HgiFormatBC7UNorm8Vec4srgb: return "pxr::HgiFormatBC7UNorm8Vec4srgb";
    case pxr::HgiFormatBC1UNorm8Vec4: return "pxr::HgiFormatBC1UNorm8Vec4";
    case pxr::HgiFormatBC3UNorm8Vec4: return "pxr::HgiFormatBC3UNorm8Vec4";
    case pxr::HgiFormatFloat32UInt8: return "pxr::HgiFormatFloat32UInt8";
    case pxr::HgiFormatPackedInt1010102: return "pxr::HgiFormatPackedInt1010102";
    case pxr::HgiFormatCount: return "pxr::HgiFormatCount";
    default: return "pxr::HgiFormat(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiShaderFunctionTessellationDesc::PatchType& x) {
    switch (x) {
    case pxr::HgiShaderFunctionTessellationDesc::PatchType::Triangles: return "pxr::HgiShaderFunctionTessellationDesc::PatchType::Triangles";
    case pxr::HgiShaderFunctionTessellationDesc::PatchType::Quads: return "pxr::HgiShaderFunctionTessellationDesc::PatchType::Quads";
    case pxr::HgiShaderFunctionTessellationDesc::PatchType::Isolines: return "pxr::HgiShaderFunctionTessellationDesc::PatchType::Isolines";
    default: return "pxr::HgiShaderFunctionTessellationDesc::PatchType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiShaderFunctionTessellationDesc::Spacing& x) {
    switch (x) {
    case pxr::HgiShaderFunctionTessellationDesc::Spacing::Equal: return "pxr::HgiShaderFunctionTessellationDesc::Spacing::Equal";
    case pxr::HgiShaderFunctionTessellationDesc::Spacing::FractionalEven: return "pxr::HgiShaderFunctionTessellationDesc::Spacing::FractionalEven";
    case pxr::HgiShaderFunctionTessellationDesc::Spacing::FractionalOdd: return "pxr::HgiShaderFunctionTessellationDesc::Spacing::FractionalOdd";
    default: return "pxr::HgiShaderFunctionTessellationDesc::Spacing(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiShaderFunctionTessellationDesc::Ordering& x) {
    switch (x) {
    case pxr::HgiShaderFunctionTessellationDesc::Ordering::CW: return "pxr::HgiShaderFunctionTessellationDesc::Ordering::CW";
    case pxr::HgiShaderFunctionTessellationDesc::Ordering::CCW: return "pxr::HgiShaderFunctionTessellationDesc::Ordering::CCW";
    default: return "pxr::HgiShaderFunctionTessellationDesc::Ordering(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiShaderFunctionGeometryDesc::InPrimitiveType& x) {
    switch (x) {
    case pxr::HgiShaderFunctionGeometryDesc::InPrimitiveType::Points: return "pxr::HgiShaderFunctionGeometryDesc::InPrimitiveType::Points";
    case pxr::HgiShaderFunctionGeometryDesc::InPrimitiveType::Lines: return "pxr::HgiShaderFunctionGeometryDesc::InPrimitiveType::Lines";
    case pxr::HgiShaderFunctionGeometryDesc::InPrimitiveType::LinesAdjacency: return "pxr::HgiShaderFunctionGeometryDesc::InPrimitiveType::LinesAdjacency";
    case pxr::HgiShaderFunctionGeometryDesc::InPrimitiveType::Triangles: return "pxr::HgiShaderFunctionGeometryDesc::InPrimitiveType::Triangles";
    case pxr::HgiShaderFunctionGeometryDesc::InPrimitiveType::TrianglesAdjacency: return "pxr::HgiShaderFunctionGeometryDesc::InPrimitiveType::TrianglesAdjacency";
    default: return "pxr::HgiShaderFunctionGeometryDesc::InPrimitiveType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiShaderFunctionGeometryDesc::OutPrimitiveType& x) {
    switch (x) {
    case pxr::HgiShaderFunctionGeometryDesc::OutPrimitiveType::Points: return "pxr::HgiShaderFunctionGeometryDesc::OutPrimitiveType::Points";
    case pxr::HgiShaderFunctionGeometryDesc::OutPrimitiveType::LineStrip: return "pxr::HgiShaderFunctionGeometryDesc::OutPrimitiveType::LineStrip";
    case pxr::HgiShaderFunctionGeometryDesc::OutPrimitiveType::TriangleStrip: return "pxr::HgiShaderFunctionGeometryDesc::OutPrimitiveType::TriangleStrip";
    default: return "pxr::HgiShaderFunctionGeometryDesc::OutPrimitiveType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiGraphicsCmdsDesc& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::HgiTessellationState::PatchType& x) {
    switch (x) {
    case pxr::HgiTessellationState::Triangle: return "pxr::HgiTessellationState::Triangle";
    case pxr::HgiTessellationState::Quad: return "pxr::HgiTessellationState::Quad";
    case pxr::HgiTessellationState::Isoline: return "pxr::HgiTessellationState::Isoline";
    default: return "pxr::HgiTessellationState::PatchType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiTessellationState::TessFactorMode& x) {
    switch (x) {
    case pxr::HgiTessellationState::Constant: return "pxr::HgiTessellationState::Constant";
    case pxr::HgiTessellationState::TessControl: return "pxr::HgiTessellationState::TessControl";
    case pxr::HgiTessellationState::TessVertex: return "pxr::HgiTessellationState::TessVertex";
    default: return "pxr::HgiTessellationState::TessFactorMode(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
#endif // #if SwiftUsd_PXR_ENABLE_IMAGING_SUPPORT
#if SwiftUsd_PXR_ENABLE_IMAGING_SUPPORT && __has_include(<Metal/Metal.h>)
std::string __Overlay::to_string(const pxr::HgiMetalArgumentIndex& x) {
    switch (x) {
    case pxr::HgiMetalArgumentIndexICB: return "pxr::HgiMetalArgumentIndexICB";
    case pxr::HgiMetalArgumentIndexConstants: return "pxr::HgiMetalArgumentIndexConstants";
    case pxr::HgiMetalArgumentIndexSamplers: return "pxr::HgiMetalArgumentIndexSamplers";
    case pxr::HgiMetalArgumentIndexTextures: return "pxr::HgiMetalArgumentIndexTextures";
    case pxr::HgiMetalArgumentIndexBuffers: return "pxr::HgiMetalArgumentIndexBuffers";
    default: return "pxr::HgiMetalArgumentIndex(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HgiMetalArgumentOffset& x) {
    switch (x) {
    case pxr::HgiMetalArgumentOffsetBufferVS: return "pxr::HgiMetalArgumentOffsetBufferVS";
    case pxr::HgiMetalArgumentOffsetBufferFS: return "pxr::HgiMetalArgumentOffsetBufferFS";
    case pxr::HgiMetalArgumentOffsetSamplerVS: return "pxr::HgiMetalArgumentOffsetSamplerVS";
    case pxr::HgiMetalArgumentOffsetSamplerFS: return "pxr::HgiMetalArgumentOffsetSamplerFS";
    case pxr::HgiMetalArgumentOffsetTextureVS: return "pxr::HgiMetalArgumentOffsetTextureVS";
    case pxr::HgiMetalArgumentOffsetTextureFS: return "pxr::HgiMetalArgumentOffsetTextureFS";
    case pxr::HgiMetalArgumentOffsetConstants: return "pxr::HgiMetalArgumentOffsetConstants";
    case pxr::HgiMetalArgumentOffsetSize: return "pxr::HgiMetalArgumentOffsetSize";
    default: return "pxr::HgiMetalArgumentOffset(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
#endif // #if SwiftUsd_PXR_ENABLE_IMAGING_SUPPORT && __has_include(<Metal/Metal.h>)
#if SwiftUsd_PXR_ENABLE_IMAGING_SUPPORT
std::string __Overlay::to_string(const pxr::HdRenderPassAovBinding& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::HdWrap& x) {
    switch (x) {
    case pxr::HdWrapClamp: return "pxr::HdWrapClamp";
    case pxr::HdWrapRepeat: return "pxr::HdWrapRepeat";
    case pxr::HdWrapBlack: return "pxr::HdWrapBlack";
    case pxr::HdWrapMirror: return "pxr::HdWrapMirror";
    case pxr::HdWrapNoOpinion: return "pxr::HdWrapNoOpinion";
    case pxr::HdWrapLegacyNoOpinionFallbackRepeat: return "pxr::HdWrapLegacyNoOpinionFallbackRepeat";
    default: return "pxr::HdWrap(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HdMinFilter& x) {
    switch (x) {
    case pxr::HdMinFilterNearest: return "pxr::HdMinFilterNearest";
    case pxr::HdMinFilterLinear: return "pxr::HdMinFilterLinear";
    case pxr::HdMinFilterNearestMipmapNearest: return "pxr::HdMinFilterNearestMipmapNearest";
    case pxr::HdMinFilterLinearMipmapNearest: return "pxr::HdMinFilterLinearMipmapNearest";
    case pxr::HdMinFilterNearestMipmapLinear: return "pxr::HdMinFilterNearestMipmapLinear";
    case pxr::HdMinFilterLinearMipmapLinear: return "pxr::HdMinFilterLinearMipmapLinear";
    default: return "pxr::HdMinFilter(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HdMagFilter& x) {
    switch (x) {
    case pxr::HdMagFilterNearest: return "pxr::HdMagFilterNearest";
    case pxr::HdMagFilterLinear: return "pxr::HdMagFilterLinear";
    default: return "pxr::HdMagFilter(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HdBorderColor& x) {
    switch (x) {
    case pxr::HdBorderColorTransparentBlack: return "pxr::HdBorderColorTransparentBlack";
    case pxr::HdBorderColorOpaqueBlack: return "pxr::HdBorderColorOpaqueBlack";
    case pxr::HdBorderColorOpaqueWhite: return "pxr::HdBorderColorOpaqueWhite";
    default: return "pxr::HdBorderColor(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HdType& x) {
    switch (x) {
    case pxr::HdTypeInvalid: return "pxr::HdTypeInvalid";
    case pxr::HdTypeBool: return "pxr::HdTypeBool";
    case pxr::HdTypeUInt8: return "pxr::HdTypeUInt8";
    case pxr::HdTypeUInt16: return "pxr::HdTypeUInt16";
    case pxr::HdTypeInt8: return "pxr::HdTypeInt8";
    case pxr::HdTypeInt16: return "pxr::HdTypeInt16";
    case pxr::HdTypeInt32: return "pxr::HdTypeInt32";
    case pxr::HdTypeInt32Vec2: return "pxr::HdTypeInt32Vec2";
    case pxr::HdTypeInt32Vec3: return "pxr::HdTypeInt32Vec3";
    case pxr::HdTypeInt32Vec4: return "pxr::HdTypeInt32Vec4";
    case pxr::HdTypeUInt32: return "pxr::HdTypeUInt32";
    case pxr::HdTypeUInt32Vec2: return "pxr::HdTypeUInt32Vec2";
    case pxr::HdTypeUInt32Vec3: return "pxr::HdTypeUInt32Vec3";
    case pxr::HdTypeUInt32Vec4: return "pxr::HdTypeUInt32Vec4";
    case pxr::HdTypeFloat: return "pxr::HdTypeFloat";
    case pxr::HdTypeFloatVec2: return "pxr::HdTypeFloatVec2";
    case pxr::HdTypeFloatVec3: return "pxr::HdTypeFloatVec3";
    case pxr::HdTypeFloatVec4: return "pxr::HdTypeFloatVec4";
    case pxr::HdTypeFloatMat3: return "pxr::HdTypeFloatMat3";
    case pxr::HdTypeFloatMat4: return "pxr::HdTypeFloatMat4";
    case pxr::HdTypeDouble: return "pxr::HdTypeDouble";
    case pxr::HdTypeDoubleVec2: return "pxr::HdTypeDoubleVec2";
    case pxr::HdTypeDoubleVec3: return "pxr::HdTypeDoubleVec3";
    case pxr::HdTypeDoubleVec4: return "pxr::HdTypeDoubleVec4";
    case pxr::HdTypeDoubleMat3: return "pxr::HdTypeDoubleMat3";
    case pxr::HdTypeDoubleMat4: return "pxr::HdTypeDoubleMat4";
    case pxr::HdTypeHalfFloat: return "pxr::HdTypeHalfFloat";
    case pxr::HdTypeHalfFloatVec2: return "pxr::HdTypeHalfFloatVec2";
    case pxr::HdTypeHalfFloatVec3: return "pxr::HdTypeHalfFloatVec3";
    case pxr::HdTypeHalfFloatVec4: return "pxr::HdTypeHalfFloatVec4";
    case pxr::HdTypeInt32_2_10_10_10_REV: return "pxr::HdTypeInt32_2_10_10_10_REV";
    case pxr::HdTypeCount: return "pxr::HdTypeCount";
    default: return "pxr::HdType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HdFormat& x) {
    switch (x) {
    case pxr::HdFormatInvalid: return "pxr::HdFormatInvalid";
    case pxr::HdFormatUNorm8: return "pxr::HdFormatUNorm8";
    case pxr::HdFormatUNorm8Vec2: return "pxr::HdFormatUNorm8Vec2";
    case pxr::HdFormatUNorm8Vec3: return "pxr::HdFormatUNorm8Vec3";
    case pxr::HdFormatUNorm8Vec4: return "pxr::HdFormatUNorm8Vec4";
    case pxr::HdFormatSNorm8: return "pxr::HdFormatSNorm8";
    case pxr::HdFormatSNorm8Vec2: return "pxr::HdFormatSNorm8Vec2";
    case pxr::HdFormatSNorm8Vec3: return "pxr::HdFormatSNorm8Vec3";
    case pxr::HdFormatSNorm8Vec4: return "pxr::HdFormatSNorm8Vec4";
    case pxr::HdFormatFloat16: return "pxr::HdFormatFloat16";
    case pxr::HdFormatFloat16Vec2: return "pxr::HdFormatFloat16Vec2";
    case pxr::HdFormatFloat16Vec3: return "pxr::HdFormatFloat16Vec3";
    case pxr::HdFormatFloat16Vec4: return "pxr::HdFormatFloat16Vec4";
    case pxr::HdFormatFloat32: return "pxr::HdFormatFloat32";
    case pxr::HdFormatFloat32Vec2: return "pxr::HdFormatFloat32Vec2";
    case pxr::HdFormatFloat32Vec3: return "pxr::HdFormatFloat32Vec3";
    case pxr::HdFormatFloat32Vec4: return "pxr::HdFormatFloat32Vec4";
    case pxr::HdFormatInt16: return "pxr::HdFormatInt16";
    case pxr::HdFormatInt16Vec2: return "pxr::HdFormatInt16Vec2";
    case pxr::HdFormatInt16Vec3: return "pxr::HdFormatInt16Vec3";
    case pxr::HdFormatInt16Vec4: return "pxr::HdFormatInt16Vec4";
    case pxr::HdFormatUInt16: return "pxr::HdFormatUInt16";
    case pxr::HdFormatUInt16Vec2: return "pxr::HdFormatUInt16Vec2";
    case pxr::HdFormatUInt16Vec3: return "pxr::HdFormatUInt16Vec3";
    case pxr::HdFormatUInt16Vec4: return "pxr::HdFormatUInt16Vec4";
    case pxr::HdFormatInt32: return "pxr::HdFormatInt32";
    case pxr::HdFormatInt32Vec2: return "pxr::HdFormatInt32Vec2";
    case pxr::HdFormatInt32Vec3: return "pxr::HdFormatInt32Vec3";
    case pxr::HdFormatInt32Vec4: return "pxr::HdFormatInt32Vec4";
    case pxr::HdFormatFloat32UInt8: return "pxr::HdFormatFloat32UInt8";
    case pxr::HdFormatCount: return "pxr::HdFormatCount";
    default: return "pxr::HdFormat(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HdCompareFunction& x) {
    switch (x) {
    case pxr::HdCmpFuncNever: return "pxr::HdCmpFuncNever";
    case pxr::HdCmpFuncLess: return "pxr::HdCmpFuncLess";
    case pxr::HdCmpFuncEqual: return "pxr::HdCmpFuncEqual";
    case pxr::HdCmpFuncLEqual: return "pxr::HdCmpFuncLEqual";
    case pxr::HdCmpFuncGreater: return "pxr::HdCmpFuncGreater";
    case pxr::HdCmpFuncNotEqual: return "pxr::HdCmpFuncNotEqual";
    case pxr::HdCmpFuncGEqual: return "pxr::HdCmpFuncGEqual";
    case pxr::HdCmpFuncAlways: return "pxr::HdCmpFuncAlways";
    case pxr::HdCmpFuncLast: return "pxr::HdCmpFuncLast";
    default: return "pxr::HdCompareFunction(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HdStencilOp& x) {
    switch (x) {
    case pxr::HdStencilOpKeep: return "pxr::HdStencilOpKeep";
    case pxr::HdStencilOpZero: return "pxr::HdStencilOpZero";
    case pxr::HdStencilOpReplace: return "pxr::HdStencilOpReplace";
    case pxr::HdStencilOpIncrement: return "pxr::HdStencilOpIncrement";
    case pxr::HdStencilOpIncrementWrap: return "pxr::HdStencilOpIncrementWrap";
    case pxr::HdStencilOpDecrement: return "pxr::HdStencilOpDecrement";
    case pxr::HdStencilOpDecrementWrap: return "pxr::HdStencilOpDecrementWrap";
    case pxr::HdStencilOpInvert: return "pxr::HdStencilOpInvert";
    case pxr::HdStencilOpLast: return "pxr::HdStencilOpLast";
    default: return "pxr::HdStencilOp(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HdBlendOp& x) {
    switch (x) {
    case pxr::HdBlendOpAdd: return "pxr::HdBlendOpAdd";
    case pxr::HdBlendOpSubtract: return "pxr::HdBlendOpSubtract";
    case pxr::HdBlendOpReverseSubtract: return "pxr::HdBlendOpReverseSubtract";
    case pxr::HdBlendOpMin: return "pxr::HdBlendOpMin";
    case pxr::HdBlendOpMax: return "pxr::HdBlendOpMax";
    case pxr::HdBlendOpLast: return "pxr::HdBlendOpLast";
    default: return "pxr::HdBlendOp(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HdBlendFactor& x) {
    switch (x) {
    case pxr::HdBlendFactorZero: return "pxr::HdBlendFactorZero";
    case pxr::HdBlendFactorOne: return "pxr::HdBlendFactorOne";
    case pxr::HdBlendFactorSrcColor: return "pxr::HdBlendFactorSrcColor";
    case pxr::HdBlendFactorOneMinusSrcColor: return "pxr::HdBlendFactorOneMinusSrcColor";
    case pxr::HdBlendFactorDstColor: return "pxr::HdBlendFactorDstColor";
    case pxr::HdBlendFactorOneMinusDstColor: return "pxr::HdBlendFactorOneMinusDstColor";
    case pxr::HdBlendFactorSrcAlpha: return "pxr::HdBlendFactorSrcAlpha";
    case pxr::HdBlendFactorOneMinusSrcAlpha: return "pxr::HdBlendFactorOneMinusSrcAlpha";
    case pxr::HdBlendFactorDstAlpha: return "pxr::HdBlendFactorDstAlpha";
    case pxr::HdBlendFactorOneMinusDstAlpha: return "pxr::HdBlendFactorOneMinusDstAlpha";
    case pxr::HdBlendFactorConstantColor: return "pxr::HdBlendFactorConstantColor";
    case pxr::HdBlendFactorOneMinusConstantColor: return "pxr::HdBlendFactorOneMinusConstantColor";
    case pxr::HdBlendFactorConstantAlpha: return "pxr::HdBlendFactorConstantAlpha";
    case pxr::HdBlendFactorOneMinusConstantAlpha: return "pxr::HdBlendFactorOneMinusConstantAlpha";
    case pxr::HdBlendFactorSrcAlphaSaturate: return "pxr::HdBlendFactorSrcAlphaSaturate";
    case pxr::HdBlendFactorSrc1Color: return "pxr::HdBlendFactorSrc1Color";
    case pxr::HdBlendFactorOneMinusSrc1Color: return "pxr::HdBlendFactorOneMinusSrc1Color";
    case pxr::HdBlendFactorSrc1Alpha: return "pxr::HdBlendFactorSrc1Alpha";
    case pxr::HdBlendFactorOneMinusSrc1Alpha: return "pxr::HdBlendFactorOneMinusSrc1Alpha";
    case pxr::HdBlendFactorLast: return "pxr::HdBlendFactorLast";
    default: return "pxr::HdBlendFactor(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HdCullStyle& x) {
    switch (x) {
    case pxr::HdCullStyleDontCare: return "pxr::HdCullStyleDontCare";
    case pxr::HdCullStyleNothing: return "pxr::HdCullStyleNothing";
    case pxr::HdCullStyleBack: return "pxr::HdCullStyleBack";
    case pxr::HdCullStyleFront: return "pxr::HdCullStyleFront";
    case pxr::HdCullStyleBackUnlessDoubleSided: return "pxr::HdCullStyleBackUnlessDoubleSided";
    case pxr::HdCullStyleFrontUnlessDoubleSided: return "pxr::HdCullStyleFrontUnlessDoubleSided";
    default: return "pxr::HdCullStyle(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HdPolygonMode& x) {
    switch (x) {
    case pxr::HdPolygonModeFill: return "pxr::HdPolygonModeFill";
    case pxr::HdPolygonModeLine: return "pxr::HdPolygonModeLine";
    default: return "pxr::HdPolygonMode(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HdMeshGeomStyle& x) {
    switch (x) {
    case pxr::HdMeshGeomStyleInvalid: return "pxr::HdMeshGeomStyleInvalid";
    case pxr::HdMeshGeomStyleSurf: return "pxr::HdMeshGeomStyleSurf";
    case pxr::HdMeshGeomStyleEdgeOnly: return "pxr::HdMeshGeomStyleEdgeOnly";
    case pxr::HdMeshGeomStyleEdgeOnSurf: return "pxr::HdMeshGeomStyleEdgeOnSurf";
    case pxr::HdMeshGeomStyleHull: return "pxr::HdMeshGeomStyleHull";
    case pxr::HdMeshGeomStyleHullEdgeOnly: return "pxr::HdMeshGeomStyleHullEdgeOnly";
    case pxr::HdMeshGeomStyleHullEdgeOnSurf: return "pxr::HdMeshGeomStyleHullEdgeOnSurf";
    case pxr::HdMeshGeomStylePoints: return "pxr::HdMeshGeomStylePoints";
    default: return "pxr::HdMeshGeomStyle(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HdBasisCurvesGeomStyle& x) {
    switch (x) {
    case pxr::HdBasisCurvesGeomStyleInvalid: return "pxr::HdBasisCurvesGeomStyleInvalid";
    case pxr::HdBasisCurvesGeomStyleWire: return "pxr::HdBasisCurvesGeomStyleWire";
    case pxr::HdBasisCurvesGeomStylePatch: return "pxr::HdBasisCurvesGeomStylePatch";
    case pxr::HdBasisCurvesGeomStylePoints: return "pxr::HdBasisCurvesGeomStylePoints";
    default: return "pxr::HdBasisCurvesGeomStyle(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HdPointsGeomStyle& x) {
    switch (x) {
    case pxr::HdPointsGeomStyleInvalid: return "pxr::HdPointsGeomStyleInvalid";
    case pxr::HdPointsGeomStylePoints: return "pxr::HdPointsGeomStylePoints";
    default: return "pxr::HdPointsGeomStyle(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HdInterpolation& x) {
    switch (x) {
    case pxr::HdInterpolationConstant: return "pxr::HdInterpolationConstant";
    case pxr::HdInterpolationUniform: return "pxr::HdInterpolationUniform";
    case pxr::HdInterpolationVarying: return "pxr::HdInterpolationVarying";
    case pxr::HdInterpolationVertex: return "pxr::HdInterpolationVertex";
    case pxr::HdInterpolationFaceVarying: return "pxr::HdInterpolationFaceVarying";
    case pxr::HdInterpolationInstance: return "pxr::HdInterpolationInstance";
    case pxr::HdInterpolationCount: return "pxr::HdInterpolationCount";
    default: return "pxr::HdInterpolation(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HdDepthPriority& x) {
    switch (x) {
    case pxr::HdDepthPriorityNearest: return "pxr::HdDepthPriorityNearest";
    case pxr::HdDepthPriorityFarthest: return "pxr::HdDepthPriorityFarthest";
    case pxr::HdDepthPriorityCount: return "pxr::HdDepthPriorityCount";
    default: return "pxr::HdDepthPriority(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HdBufferArrayUsageHintBits& x) {
    switch (x) {
    case pxr::HdBufferArrayUsageHintBitsImmutable: return "pxr::HdBufferArrayUsageHintBitsImmutable";
    case pxr::HdBufferArrayUsageHintBitsSizeVarying: return "pxr::HdBufferArrayUsageHintBitsSizeVarying";
    case pxr::HdBufferArrayUsageHintBitsUniform: return "pxr::HdBufferArrayUsageHintBitsUniform";
    case pxr::HdBufferArrayUsageHintBitsStorage: return "pxr::HdBufferArrayUsageHintBitsStorage";
    case pxr::HdBufferArrayUsageHintBitsVertex: return "pxr::HdBufferArrayUsageHintBitsVertex";
    case pxr::HdBufferArrayUsageHintBitsIndex: return "pxr::HdBufferArrayUsageHintBitsIndex";
    default: return "pxr::HdBufferArrayUsageHintBits(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HdReprSelector& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::HdBasisCurvesTopology& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::HdTopology& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::HdGeomSubset::Type& x) {
    switch (x) {
    case pxr::HdGeomSubset::TypeFaceSet: return "pxr::HdGeomSubset::TypeFaceSet";
    default: return "pxr::HdGeomSubset::Type(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HdRprimCollection& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::HdDataSourceLocator& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::HdDataSourceLocatorSet& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::HdCamera::DirtyBits& x) {
    switch (x) {
    case pxr::HdCamera::Clean: return "pxr::HdCamera::Clean";
    case pxr::HdCamera::DirtyTransform: return "pxr::HdCamera::DirtyTransform";
    case pxr::HdCamera::DirtyParams: return "pxr::HdCamera::DirtyParams";
    case pxr::HdCamera::DirtyClipPlanes: return "pxr::HdCamera::DirtyClipPlanes";
    case pxr::HdCamera::DirtyWindowPolicy: return "pxr::HdCamera::DirtyWindowPolicy";
    case pxr::HdCamera::AllDirty: return "pxr::HdCamera::AllDirty";
    default: return "pxr::HdCamera::DirtyBits(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HdCamera::Projection& x) {
    switch (x) {
    case pxr::HdCamera::Perspective: return "pxr::HdCamera::Perspective";
    case pxr::HdCamera::Orthographic: return "pxr::HdCamera::Orthographic";
    default: return "pxr::HdCamera::Projection(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HdCollectionExpressionEvaluator::MatchKind& x) {
    switch (x) {
    case pxr::HdCollectionExpressionEvaluator::MatchAll: return "pxr::HdCollectionExpressionEvaluator::MatchAll";
    case pxr::HdCollectionExpressionEvaluator::ShallowestMatches: return "pxr::HdCollectionExpressionEvaluator::ShallowestMatches";
    case pxr::HdCollectionExpressionEvaluator::ShallowestMatchesAndAllDescendants: return "pxr::HdCollectionExpressionEvaluator::ShallowestMatchesAndAllDescendants";
    default: return "pxr::HdCollectionExpressionEvaluator::MatchKind(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HdCoordSys::DirtyBits& x) {
    switch (x) {
    case pxr::HdCoordSys::Clean: return "pxr::HdCoordSys::Clean";
    case pxr::HdCoordSys::DirtyName: return "pxr::HdCoordSys::DirtyName";
    case pxr::HdCoordSys::DirtyTransform: return "pxr::HdCoordSys::DirtyTransform";
    case pxr::HdCoordSys::AllDirty: return "pxr::HdCoordSys::AllDirty";
    default: return "pxr::HdCoordSys::DirtyBits(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HdField::DirtyBits& x) {
    switch (x) {
    case pxr::HdField::Clean: return "pxr::HdField::Clean";
    case pxr::HdField::DirtyTransform: return "pxr::HdField::DirtyTransform";
    case pxr::HdField::DirtyParams: return "pxr::HdField::DirtyParams";
    case pxr::HdField::AllDirty: return "pxr::HdField::AllDirty";
    default: return "pxr::HdField::DirtyBits(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HdMaterialNetwork& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::HdMaterialNetworkMap& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::HdMaterialNode2& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::HdLight::DirtyBits& x) {
    switch (x) {
    case pxr::HdLight::Clean: return "pxr::HdLight::Clean";
    case pxr::HdLight::DirtyTransform: return "pxr::HdLight::DirtyTransform";
    case pxr::HdLight::DirtyParams: return "pxr::HdLight::DirtyParams";
    case pxr::HdLight::DirtyShadowParams: return "pxr::HdLight::DirtyShadowParams";
    case pxr::HdLight::DirtyCollection: return "pxr::HdLight::DirtyCollection";
    case pxr::HdLight::DirtyResource: return "pxr::HdLight::DirtyResource";
    case pxr::HdLight::DirtyInstancer: return "pxr::HdLight::DirtyInstancer";
    case pxr::HdLight::AllDirty: return "pxr::HdLight::AllDirty";
    default: return "pxr::HdLight::DirtyBits(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HdPrimOriginSchema::OriginPath& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::HdRenderBuffer::DirtyBits& x) {
    switch (x) {
    case pxr::HdRenderBuffer::Clean: return "pxr::HdRenderBuffer::Clean";
    case pxr::HdRenderBuffer::DirtyDescription: return "pxr::HdRenderBuffer::DirtyDescription";
    default: return "pxr::HdRenderBuffer::DirtyBits(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HdRenderPassState::ColorMask& x) {
    switch (x) {
    case pxr::HdRenderPassState::ColorMaskNone: return "pxr::HdRenderPassState::ColorMaskNone";
    case pxr::HdRenderPassState::ColorMaskRGB: return "pxr::HdRenderPassState::ColorMaskRGB";
    case pxr::HdRenderPassState::ColorMaskRGBA: return "pxr::HdRenderPassState::ColorMaskRGBA";
    default: return "pxr::HdRenderPassState::ColorMask(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HdSceneIndexPluginRegistry::InsertionOrder& x) {
    switch (x) {
    case pxr::HdSceneIndexPluginRegistry::InsertionOrderAtStart: return "pxr::HdSceneIndexPluginRegistry::InsertionOrderAtStart";
    case pxr::HdSceneIndexPluginRegistry::InsertionOrderAtEnd: return "pxr::HdSceneIndexPluginRegistry::InsertionOrderAtEnd";
    default: return "pxr::HdSceneIndexPluginRegistry::InsertionOrder(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HdGpGenerativeProcedural::AsyncState& x) {
    switch (x) {
    case pxr::HdGpGenerativeProcedural::Continuing: return "pxr::HdGpGenerativeProcedural::Continuing";
    case pxr::HdGpGenerativeProcedural::Finished: return "pxr::HdGpGenerativeProcedural::Finished";
    case pxr::HdGpGenerativeProcedural::ContinuingWithNewChanges: return "pxr::HdGpGenerativeProcedural::ContinuingWithNewChanges";
    case pxr::HdGpGenerativeProcedural::FinishedWithNewChanges: return "pxr::HdGpGenerativeProcedural::FinishedWithNewChanges";
    default: return "pxr::HdGpGenerativeProcedural::AsyncState(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HdsiLegacyDisplayStyleOverrideSceneIndex::OptionalInt& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::HdStBinding::Type& x) {
    switch (x) {
    case pxr::HdStBinding::UNKNOWN: return "pxr::HdStBinding::UNKNOWN";
    case pxr::HdStBinding::DISPATCH: return "pxr::HdStBinding::DISPATCH";
    case pxr::HdStBinding::DRAW_INDEX: return "pxr::HdStBinding::DRAW_INDEX";
    case pxr::HdStBinding::DRAW_INDEX_INSTANCE: return "pxr::HdStBinding::DRAW_INDEX_INSTANCE";
    case pxr::HdStBinding::DRAW_INDEX_INSTANCE_ARRAY: return "pxr::HdStBinding::DRAW_INDEX_INSTANCE_ARRAY";
    case pxr::HdStBinding::VERTEX_ATTR: return "pxr::HdStBinding::VERTEX_ATTR";
    case pxr::HdStBinding::INDEX_ATTR: return "pxr::HdStBinding::INDEX_ATTR";
    case pxr::HdStBinding::SSBO: return "pxr::HdStBinding::SSBO";
    case pxr::HdStBinding::BINDLESS_SSBO_RANGE: return "pxr::HdStBinding::BINDLESS_SSBO_RANGE";
    case pxr::HdStBinding::UBO: return "pxr::HdStBinding::UBO";
    case pxr::HdStBinding::BINDLESS_UNIFORM: return "pxr::HdStBinding::BINDLESS_UNIFORM";
    case pxr::HdStBinding::UNIFORM: return "pxr::HdStBinding::UNIFORM";
    case pxr::HdStBinding::UNIFORM_ARRAY: return "pxr::HdStBinding::UNIFORM_ARRAY";
    case pxr::HdStBinding::FALLBACK: return "pxr::HdStBinding::FALLBACK";
    case pxr::HdStBinding::TEXTURE_2D: return "pxr::HdStBinding::TEXTURE_2D";
    case pxr::HdStBinding::ARRAY_OF_TEXTURE_2D: return "pxr::HdStBinding::ARRAY_OF_TEXTURE_2D";
    case pxr::HdStBinding::TEXTURE_FIELD: return "pxr::HdStBinding::TEXTURE_FIELD";
    case pxr::HdStBinding::TEXTURE_UDIM_ARRAY: return "pxr::HdStBinding::TEXTURE_UDIM_ARRAY";
    case pxr::HdStBinding::TEXTURE_UDIM_LAYOUT: return "pxr::HdStBinding::TEXTURE_UDIM_LAYOUT";
    case pxr::HdStBinding::TEXTURE_PTEX_TEXEL: return "pxr::HdStBinding::TEXTURE_PTEX_TEXEL";
    case pxr::HdStBinding::TEXTURE_PTEX_LAYOUT: return "pxr::HdStBinding::TEXTURE_PTEX_LAYOUT";
    case pxr::HdStBinding::BINDLESS_TEXTURE_2D: return "pxr::HdStBinding::BINDLESS_TEXTURE_2D";
    case pxr::HdStBinding::BINDLESS_ARRAY_OF_TEXTURE_2D: return "pxr::HdStBinding::BINDLESS_ARRAY_OF_TEXTURE_2D";
    case pxr::HdStBinding::BINDLESS_TEXTURE_FIELD: return "pxr::HdStBinding::BINDLESS_TEXTURE_FIELD";
    case pxr::HdStBinding::BINDLESS_TEXTURE_UDIM_ARRAY: return "pxr::HdStBinding::BINDLESS_TEXTURE_UDIM_ARRAY";
    case pxr::HdStBinding::BINDLESS_TEXTURE_UDIM_LAYOUT: return "pxr::HdStBinding::BINDLESS_TEXTURE_UDIM_LAYOUT";
    case pxr::HdStBinding::BINDLESS_TEXTURE_PTEX_TEXEL: return "pxr::HdStBinding::BINDLESS_TEXTURE_PTEX_TEXEL";
    case pxr::HdStBinding::BINDLESS_TEXTURE_PTEX_LAYOUT: return "pxr::HdStBinding::BINDLESS_TEXTURE_PTEX_LAYOUT";
    case pxr::HdStBinding::PRIMVAR_REDIRECT: return "pxr::HdStBinding::PRIMVAR_REDIRECT";
    case pxr::HdStBinding::FIELD_REDIRECT: return "pxr::HdStBinding::FIELD_REDIRECT";
    case pxr::HdStBinding::TRANSFORM_2D: return "pxr::HdStBinding::TRANSFORM_2D";
    default: return "pxr::HdStBinding::Type(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HdStBinding::Location& x) {
    switch (x) {
    case pxr::HdStBinding::NOT_EXIST: return "pxr::HdStBinding::NOT_EXIST";
    default: return "pxr::HdStBinding::Location(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HdStTextureType& x) {
    switch (x) {
    case pxr::HdStTextureType::Uv: return "pxr::HdStTextureType::Uv";
    case pxr::HdStTextureType::Field: return "pxr::HdStTextureType::Field";
    case pxr::HdStTextureType::Ptex: return "pxr::HdStTextureType::Ptex";
    case pxr::HdStTextureType::Udim: return "pxr::HdStTextureType::Udim";
    default: return "pxr::HdStTextureType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HdStComputeQueue& x) {
    switch (x) {
    case pxr::HdStComputeQueueZero: return "pxr::HdStComputeQueueZero";
    case pxr::HdStComputeQueueOne: return "pxr::HdStComputeQueueOne";
    case pxr::HdStComputeQueueTwo: return "pxr::HdStComputeQueueTwo";
    case pxr::HdStComputeQueueThree: return "pxr::HdStComputeQueueThree";
    case pxr::HdStComputeQueueCount: return "pxr::HdStComputeQueueCount";
    default: return "pxr::HdStComputeQueue(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::HdxAovInputTaskParams& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::HdxBoundingBoxTaskParams& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::HdxColorizeSelectionTaskParams& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::HdxColorChannelTaskParams& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::HdxColorCorrectionTaskParams& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::HdxDrawTargetTaskParams& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::HdxRenderTaskParams& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::HdxOitResolveTaskParams& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::HdxPickTaskParams& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::HdxPickHit& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::HdxPickTaskContextParams& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::HdxPickFromRenderBufferTaskParams& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::HdxPresentTaskParams& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::HdxSelectionTaskParams& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::HdxShadowTaskParams& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::HdxSimpleLightTaskParams& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::HdxShadowParams& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::HdxShaderInputs& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
std::string __Overlay::to_string(const pxr::HdxVisualizeAovTaskParams& x) {
    std::stringstream ss;
    ss << x;
    return ss.str();
}
#endif // #if SwiftUsd_PXR_ENABLE_IMAGING_SUPPORT
#if SwiftUsd_PXR_ENABLE_USD_IMAGING_SUPPORT
std::string __Overlay::to_string(const pxr::UsdImagingPropertyInvalidationType& x) {
    switch (x) {
    case pxr::UsdImagingPropertyInvalidationType::Update: return "pxr::UsdImagingPropertyInvalidationType::Update";
    case pxr::UsdImagingPropertyInvalidationType::Resync: return "pxr::UsdImagingPropertyInvalidationType::Resync";
    default: return "pxr::UsdImagingPropertyInvalidationType(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::UsdImagingPrimAdapter::PopulationMode& x) {
    switch (x) {
    case pxr::UsdImagingPrimAdapter::RepresentsSelf: return "pxr::UsdImagingPrimAdapter::RepresentsSelf";
    case pxr::UsdImagingPrimAdapter::RepresentsSelfAndDescendents: return "pxr::UsdImagingPrimAdapter::RepresentsSelfAndDescendents";
    case pxr::UsdImagingPrimAdapter::RepresentedByAncestor: return "pxr::UsdImagingPrimAdapter::RepresentedByAncestor";
    default: return "pxr::UsdImagingPrimAdapter::PopulationMode(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::UsdImagingGLDrawMode& x) {
    switch (x) {
    case pxr::UsdImagingGLDrawMode::DRAW_POINTS: return "pxr::UsdImagingGLDrawMode::DRAW_POINTS";
    case pxr::UsdImagingGLDrawMode::DRAW_WIREFRAME: return "pxr::UsdImagingGLDrawMode::DRAW_WIREFRAME";
    case pxr::UsdImagingGLDrawMode::DRAW_WIREFRAME_ON_SURFACE: return "pxr::UsdImagingGLDrawMode::DRAW_WIREFRAME_ON_SURFACE";
    case pxr::UsdImagingGLDrawMode::DRAW_SHADED_FLAT: return "pxr::UsdImagingGLDrawMode::DRAW_SHADED_FLAT";
    case pxr::UsdImagingGLDrawMode::DRAW_SHADED_SMOOTH: return "pxr::UsdImagingGLDrawMode::DRAW_SHADED_SMOOTH";
    case pxr::UsdImagingGLDrawMode::DRAW_GEOM_ONLY: return "pxr::UsdImagingGLDrawMode::DRAW_GEOM_ONLY";
    case pxr::UsdImagingGLDrawMode::DRAW_GEOM_FLAT: return "pxr::UsdImagingGLDrawMode::DRAW_GEOM_FLAT";
    case pxr::UsdImagingGLDrawMode::DRAW_GEOM_SMOOTH: return "pxr::UsdImagingGLDrawMode::DRAW_GEOM_SMOOTH";
    default: return "pxr::UsdImagingGLDrawMode(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::UsdImagingGLCullStyle& x) {
    switch (x) {
    case pxr::UsdImagingGLCullStyle::CULL_STYLE_NO_OPINION: return "pxr::UsdImagingGLCullStyle::CULL_STYLE_NO_OPINION";
    case pxr::UsdImagingGLCullStyle::CULL_STYLE_NOTHING: return "pxr::UsdImagingGLCullStyle::CULL_STYLE_NOTHING";
    case pxr::UsdImagingGLCullStyle::CULL_STYLE_BACK: return "pxr::UsdImagingGLCullStyle::CULL_STYLE_BACK";
    case pxr::UsdImagingGLCullStyle::CULL_STYLE_FRONT: return "pxr::UsdImagingGLCullStyle::CULL_STYLE_FRONT";
    case pxr::UsdImagingGLCullStyle::CULL_STYLE_BACK_UNLESS_DOUBLE_SIDED: return "pxr::UsdImagingGLCullStyle::CULL_STYLE_BACK_UNLESS_DOUBLE_SIDED";
    case pxr::UsdImagingGLCullStyle::CULL_STYLE_COUNT: return "pxr::UsdImagingGLCullStyle::CULL_STYLE_COUNT";
    default: return "pxr::UsdImagingGLCullStyle(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
std::string __Overlay::to_string(const pxr::UsdImagingGLRendererSetting::Type& x) {
    switch (x) {
    case pxr::UsdImagingGLRendererSetting::TYPE_FLAG: return "pxr::UsdImagingGLRendererSetting::TYPE_FLAG";
    case pxr::UsdImagingGLRendererSetting::TYPE_INT: return "pxr::UsdImagingGLRendererSetting::TYPE_INT";
    case pxr::UsdImagingGLRendererSetting::TYPE_FLOAT: return "pxr::UsdImagingGLRendererSetting::TYPE_FLOAT";
    case pxr::UsdImagingGLRendererSetting::TYPE_STRING: return "pxr::UsdImagingGLRendererSetting::TYPE_STRING";
    default: return "pxr::UsdImagingGLRendererSetting::Type(rawValue: " + std::to_string(static_cast<int64_t>(x)) + ")";
    }
}
#endif // #if SwiftUsd_PXR_ENABLE_USD_IMAGING_SUPPORT
